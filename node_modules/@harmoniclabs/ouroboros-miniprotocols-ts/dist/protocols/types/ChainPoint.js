"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainPoint = void 0;
exports.isIBlockHeaderHash = isIBlockHeaderHash;
exports.isIChainPoint = isIChainPoint;
exports.isOriginPoint = isOriginPoint;
exports.isRealPoint = isRealPoint;
var cbor_1 = require("@harmoniclabs/cbor");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var ints_1 = require("./ints.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
function isIBlockHeaderHash(stuff) {
    return ((0, obj_utils_1.isObject)(stuff) &&
        (0, ints_1.canBeUInteger)(stuff.slotNumber) &&
        (stuff.hash instanceof Uint8Array));
}
function isIChainPoint(stuff) {
    return ((0, obj_utils_1.isObject)(stuff) &&
        (typeof stuff.blockHeader === "undefined" ||
            isIBlockHeaderHash(stuff.blockHeader)));
}
function isOriginPoint(point) {
    return typeof point.blockHeader === "undefined" || !isIBlockHeaderHash(point.blockHeader);
}
function isRealPoint(point) {
    return isIBlockHeaderHash(point.blockHeader);
}
var ChainPoint = /** @class */ (function () {
    function ChainPoint(chainPoint) {
        if (!isIChainPoint(chainPoint))
            throw new Error("invalid IChainPoint interface");
        this.blockHeader = chainPoint.blockHeader ? __assign({}, chainPoint.blockHeader) : undefined;
    }
    ChainPoint.prototype.isOrigin = function () { return isOriginPoint(this); };
    Object.defineProperty(ChainPoint, "origin", {
        get: function () {
            return new ChainPoint({});
        },
        enumerable: false,
        configurable: true
    });
    ChainPoint.prototype.toJSON = function () { return this.toJson(); };
    ChainPoint.prototype.toJson = function () {
        if (this.isOrigin())
            return {};
        return {
            blockHeader: {
                hash: (0, uint8array_utils_1.toHex)(this.blockHeader.hash),
                slot: Number(this.blockHeader.slotNumber)
            }
        };
    };
    ChainPoint.prototype.toString = function () {
        if (this.isOrigin())
            return "(point: origin)";
        return "(point: ( hash: ".concat((0, uint8array_utils_1.toHex)(this.blockHeader.hash), ", slot: ").concat(this.blockHeader.slotNumber, " ))");
    };
    ChainPoint.prototype.toCborBytes = function () {
        return this.toCbor().toBuffer();
    };
    ChainPoint.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    ChainPoint.prototype.toCborObj = function () {
        if (this.isOrigin() || this.blockHeader === undefined)
            return new cbor_1.CborArray([]);
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.blockHeader.slotNumber),
            new cbor_1.CborBytes(this.blockHeader.hash)
        ]);
    };
    ChainPoint.fromCbor = function (cbor) {
        return ChainPoint.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cbor)));
    };
    ChainPoint.fromCborObj = function (cbor) {
        if (!(cbor instanceof cbor_1.CborArray))
            throw new Error("invalid CBOR for 'ChainPoint'");
        if (cbor.array.length === 0)
            return new ChainPoint({}); // origin
        var _a = __read(cbor.array, 2), slot = _a[0], hash = _a[1];
        if (!(slot instanceof cbor_1.CborUInt &&
            hash instanceof cbor_1.CborBytes))
            throw new Error("invalid CBOR for 'ChainPoint'");
        return new ChainPoint({
            blockHeader: {
                slotNumber: slot.num,
                hash: hash.bytes
            }
        });
    };
    ChainPoint.eq = function (a, b) {
        return ((a.blockHeader === undefined && b.blockHeader === undefined) ||
            (isIBlockHeaderHash(a.blockHeader) &&
                isIBlockHeaderHash(b.blockHeader) &&
                BigInt(a.blockHeader.slotNumber) === BigInt(b.blockHeader.slotNumber) &&
                (0, uint8array_utils_1.uint8ArrayEq)(a.blockHeader.hash, b.blockHeader.hash)));
    };
    return ChainPoint;
}());
exports.ChainPoint = ChainPoint;
