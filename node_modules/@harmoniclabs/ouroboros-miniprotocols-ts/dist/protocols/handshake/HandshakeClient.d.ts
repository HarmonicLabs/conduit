import { Multiplexer } from "../../multiplexer/index.js";
import { VersionTableMap } from "./HandshakeVersionTable/HandshakeVersionTable.js";
import { IVersionData, VersionData } from "./HandshakeVersionTable/VersionData.js";
import { HandshakeAcceptVersion } from "./messages/HandshakeAcceptVersion.js";
import { HandshakeMessage } from "./messages/HandshakeMessage.js";
import { HandshakeProposeVersion } from "./messages/HandshakeProposeVersion.js";
import { HandshakeQueryReply } from "./messages/HandshakeQueryReply.js";
import { HandshakeRefuse } from "./messages/HandshakeRefuse.js";
import { AddEvtListenerOpts } from "../../common/AddEvtListenerOpts.js";
import { NetworkMagic } from "./HandshakeVersionTable/index.js";
export interface ProposeOpts {
    includeN2COldVersions: boolean;
}
type HandshakeClientEvtName = keyof Omit<HandshakeClientEvtListeners, "error">;
type AnyHandshakeClientEvtName = HandshakeClientEvtName | "error";
type HandshakeClientEvtListeners = {
    propose: HandshakeClientEvtListener[];
    accept: HandshakeClientEvtListener[];
    refuse: HandshakeClientEvtListener[];
    queryReply: HandshakeClientEvtListener[];
    error: ((err: Error) => void)[];
};
type HandshakeClientEvtListener = (msg: HandshakeMessage) => void;
type AnyHandshakeClientEvtListener = HandshakeClientEvtListener | ((err: Error) => void);
type EvtListenerOf<EvtName extends AnyHandshakeClientEvtName> = EvtName extends "propose" ? (msg: HandshakeProposeVersion) => void : EvtName extends "accept" ? (msg: HandshakeAcceptVersion) => void : EvtName extends "refuse" ? (msg: HandshakeRefuse) => void : EvtName extends "queryReply" ? (msg: HandshakeQueryReply) => void : EvtName extends "error" ? (err: Error) => void : never;
type DataOf<EvtName extends AnyHandshakeClientEvtName> = EvtName extends "propose" ? HandshakeProposeVersion : EvtName extends "accept" ? HandshakeAcceptVersion : EvtName extends "refuse" ? HandshakeRefuse : EvtName extends "queryReply" ? HandshakeQueryReply : EvtName extends "error" ? Error : never;
export declare class HandshakeClient {
    readonly mplexer: Multiplexer;
    private _mplexerListener;
    /**
     * removes the listener on the multiplexer added on contructor call
     *
     * after this method is called, the instance is useless.
     **/
    terminate(): void;
    constructor(multiplexer: Multiplexer);
    propose(
    /** @default versionTable defaults to all the known versions (depending by n2n or n2c) */
    arg?: VersionTableMap | IVersionData | VersionData | NetworkMagic, opts?: Partial<ProposeOpts>): Promise<HandshakeAcceptVersion | HandshakeRefuse | HandshakeQueryReply>;
    private readonly _listeners;
    private readonly _onceListeners;
    hasEventListeners(includeError?: boolean): boolean;
    clearListeners(evt?: HandshakeClientEvtName): this;
    removeAllListeners(evt?: HandshakeClientEvtName): this;
    once<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, listener: EvtListenerOf<EvtName>): this;
    addEventListenerOnce<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, listener: EvtListenerOf<EvtName>): this;
    on<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, listener: EvtListenerOf<EvtName>, opts?: AddEvtListenerOpts): this;
    addEventListener<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, listener: EvtListenerOf<EvtName>): this;
    addListener<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, listener: EvtListenerOf<EvtName>): this;
    off(evt: HandshakeClientEvtName, listener: AnyHandshakeClientEvtListener): this;
    removeEventListener(evt: HandshakeClientEvtName, listener: AnyHandshakeClientEvtListener): this;
    removeListener(evt: HandshakeClientEvtName, listener: AnyHandshakeClientEvtListener): this;
    dispatchEvent<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, msg: DataOf<EvtName>): boolean;
    emit<EvtName extends AnyHandshakeClientEvtName>(evt: EvtName, msg: DataOf<EvtName>): boolean;
}
export {};
