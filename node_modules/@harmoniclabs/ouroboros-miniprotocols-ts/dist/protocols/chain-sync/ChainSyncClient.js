"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainSyncClient = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var MiniProtocol_1 = require("../../MiniProtocol/index.js");
var ChainSyncMessage_1 = require("./ChainSyncMessage.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var messages_1 = require("./messages/index.js");
var roDescr = Object.freeze({
    writable: false,
    enumerable: true,
    configurable: false
});
function isChainSyncClientEvtName(str) {
    return (str === "rollBackwards" ||
        str === "rollForward" ||
        str === "intersectFound" ||
        str === "intersectNotFound" ||
        str === "awaitReply");
}
function isAnyChainSyncClientEvtName(str) {
    return isChainSyncClientEvtName(str) || str === "error";
}
function msgToName(msg) {
    if (msg instanceof messages_1.ChainSyncRollBackwards)
        return "rollBackwards";
    if (msg instanceof messages_1.ChainSyncRollForward)
        return "rollForward";
    if (msg instanceof messages_1.ChainSyncIntersectFound)
        return "intersectFound";
    if (msg instanceof messages_1.ChainSyncIntersectNotFound)
        return "intersectNotFound";
    if (msg instanceof messages_1.ChainSyncAwaitReply)
        return "awaitReply";
    return undefined;
}
var ChainSyncClient = /** @class */ (function () {
    function ChainSyncClient(multiplexer) {
        var self = this;
        var eventListeners = {
            rollBackwards: [],
            rollForward: [],
            intersectFound: [],
            intersectNotFound: [],
            awaitReply: [],
            error: []
        };
        var onceEventListeners = {
            rollBackwards: [],
            rollForward: [],
            intersectFound: [],
            intersectNotFound: [],
            awaitReply: [],
            error: []
        };
        function clearListeners(evt) {
            if (isAnyChainSyncClientEvtName(evt)) {
                eventListeners[evt].length = 0;
                onceEventListeners[evt].length = 0;
                return self;
            }
            eventListeners.rollBackwards.length = 0;
            eventListeners.rollForward.length = 0;
            eventListeners.intersectFound.length = 0;
            eventListeners.intersectNotFound.length = 0;
            eventListeners.awaitReply.length = 0;
            onceEventListeners.rollBackwards.length = 0;
            onceEventListeners.rollForward.length = 0;
            onceEventListeners.intersectFound.length = 0;
            onceEventListeners.intersectNotFound.length = 0;
            onceEventListeners.awaitReply.length = 0;
            return self;
        }
        function hasEventListeners(includeError) {
            if (includeError === void 0) { includeError = false; }
            return (includeError ? (eventListeners.error.length > 0 ||
                onceEventListeners.error.length > 0) : true) && (eventListeners.rollBackwards.length > 0 ||
                eventListeners.rollForward.length > 0 ||
                eventListeners.intersectFound.length > 0 ||
                eventListeners.intersectNotFound.length > 0 ||
                eventListeners.awaitReply.length > 0 ||
                onceEventListeners.rollBackwards.length > 0 ||
                onceEventListeners.rollForward.length > 0 ||
                onceEventListeners.intersectFound.length > 0 ||
                onceEventListeners.intersectNotFound.length > 0 ||
                onceEventListeners.awaitReply.length > 0);
        }
        /** @deprecated */
        function onRollBackwards(cb) {
            eventListeners.rollBackwards.push(cb);
        }
        /** @deprecated */
        function onRollForward(cb) {
            eventListeners.rollForward.push(cb);
        }
        /** @deprecated */
        function onIntersectFound(cb) {
            eventListeners.intersectFound.push(cb);
        }
        /** @deprecated */
        function onIntersectNotFound(cb) {
            eventListeners.intersectNotFound.push(cb);
        }
        /** @deprecated */
        function onAwaitReply(cb) {
            eventListeners.awaitReply.push(cb);
        }
        function addEventListenerOnce(evt, listener) {
            if (!isAnyChainSyncClientEvtName(evt))
                return self;
            onceEventListeners[evt].push(listener);
            return self;
        }
        function addEventListener(evt, listener, opts) {
            if ((opts === null || opts === void 0 ? void 0 : opts.once) === true)
                return addEventListenerOnce(evt, listener);
            if (!isAnyChainSyncClientEvtName(evt))
                return self;
            eventListeners[evt].push(listener);
            return self;
        }
        function removeEventListener(evt, listener) {
            if (!isAnyChainSyncClientEvtName(evt))
                return self;
            eventListeners[evt] = eventListeners[evt].filter(function (fn) { return fn !== listener; });
            onceEventListeners[evt] = onceEventListeners[evt].filter(function (fn) { return fn !== listener; });
            return self;
        }
        function dispatchEvent(evt, msg) {
            if (!isAnyChainSyncClientEvtName(evt))
                return true;
            if (evt !== "error" && !(0, ChainSyncMessage_1.isChainSyncMessage)(msg))
                return true;
            var listeners = eventListeners[evt];
            var nListeners = listeners.length;
            for (var i = 0; i < nListeners; i++) {
                listeners[i](msg);
            }
            var onceListeners = onceEventListeners[evt];
            if (evt === "error" && nListeners + onceListeners.length === 0) {
                throw msg instanceof Error ? msg : new Error("Unhandled error: " + msg);
            }
            var cb;
            while (cb = onceListeners.shift()) {
                cb(msg);
            }
            return true;
        }
        Object.defineProperties(this, {
            mplexer: __assign({ value: multiplexer }, roDescr),
            clearListeners: __assign({ value: clearListeners }, roDescr),
            removeAllListeners: __assign({ value: clearListeners }, roDescr),
            onRollBackwards: __assign({ value: onRollBackwards }, roDescr),
            onRollForward: __assign({ value: onRollForward }, roDescr),
            onIntersectFound: __assign({ value: onIntersectFound }, roDescr),
            onIntersectNotFound: __assign({ value: onIntersectNotFound }, roDescr),
            onAwaitReply: __assign({ value: onAwaitReply }, roDescr),
            addEventListener: __assign({ value: addEventListener }, roDescr),
            addListener: __assign({ value: addEventListener }, roDescr),
            on: __assign({ value: addEventListener }, roDescr),
            once: __assign({ value: addEventListenerOnce }, roDescr),
            removeEventListener: __assign({ value: removeEventListener }, roDescr),
            removeListener: __assign({ value: removeEventListener }, roDescr),
            off: __assign({ value: removeEventListener }, roDescr),
            dispatchEvent: __assign({ value: dispatchEvent }, roDescr),
            emit: __assign({ value: dispatchEvent }, roDescr),
        });
        var prevBytes = undefined;
        var queque = [];
        multiplexer.on(MiniProtocol_1.MiniProtocol.ChainSync, function (chunk) {
            if (!hasEventListeners())
                return;
            var offset = -1;
            var thing;
            var msg;
            if (prevBytes) {
                var tmp = new Uint8Array(prevBytes.length + chunk.length);
                tmp.set(prevBytes, 0);
                tmp.set(chunk, prevBytes.length);
                chunk = tmp;
                prevBytes = undefined;
            }
            while (offset < chunk.length) {
                var originalSTLimit = Error.stackTraceLimit;
                Error.stackTraceLimit = 0;
                try {
                    thing = cbor_1.Cbor.parseWithOffset(chunk);
                }
                catch (_a) {
                    Error.stackTraceLimit = originalSTLimit;
                    // assume the error is of "missing bytes";
                    prevBytes = Uint8Array.prototype.slice.call(chunk);
                    break;
                }
                offset = thing.offset;
                // console.log( "msg byetes", offset, toHex( chunk.subarray( 0, offset ) ) );
                // Error.stackTraceLimit = 0;
                try {
                    msg = (0, ChainSyncMessage_1.chainSyncMessageFromCborObj)(thing.parsed);
                    // @ts-ignore Cannot assign to 'cborBytes' because it is a read-only property.ts(2540)
                    msg.cborBytes = Uint8Array.prototype.slice.call(chunk, 0, offset);
                    queque.unshift(msg);
                }
                catch (e) {
                    // before dispatch event
                    Error.stackTraceLimit = originalSTLimit;
                    var err = new Error(typeof (e === null || e === void 0 ? void 0 : e.message) === "string" ? e.message : "" +
                        "\ndata: " + (0, uint8array_utils_1.toHex)(chunk) + "\n");
                    dispatchEvent("error", err);
                }
                finally {
                    Error.stackTraceLimit = originalSTLimit;
                }
                if (offset < chunk.length) {
                    // reference same memory (`subarray`)
                    // ignore the parsed bytes
                    chunk = chunk.subarray(offset);
                    offset = -1;
                }
            }
            var msgStr;
            while (msg = queque.pop()) {
                msgStr = msgToName(msg);
                if (!msgStr)
                    continue; // ingore messages not expected by the client
                dispatchEvent(msgStr, msg);
            }
        });
    }
    ChainSyncClient.prototype.requestNext = function () {
        var _this = this;
        var self = this;
        return new Promise(function (resolve) {
            function resolveForward(msg) {
                self.removeEventListener("rollForward", resolveForward);
                self.removeEventListener("rollBackwards", resolveBackwards);
                resolve(msg);
            }
            function resolveBackwards(msg) {
                self.removeEventListener("rollForward", resolveForward);
                self.removeEventListener("rollBackwards", resolveBackwards);
                resolve(msg);
            }
            _this.once("rollForward", resolveForward);
            _this.once("rollBackwards", resolveBackwards);
            _this.mplexer.send(new messages_1.ChainSyncRequestNext().toCbor().toBuffer(), {
                hasAgency: true,
                protocol: _this.mplexer.isN2N ?
                    MiniProtocol_1.MiniProtocol.ChainSync :
                    MiniProtocol_1.MiniProtocol.LocalChainSync
            });
        });
    };
    ChainSyncClient.prototype.findIntersect = function (points) {
        var _this = this;
        var self = this;
        return new Promise(function (resolve) {
            function resolveFound(msg) {
                self.removeEventListener("intersectFound", resolveFound);
                self.removeEventListener("intersectNotFound", resolveNotFound);
                resolve(msg);
            }
            function resolveNotFound(msg) {
                self.removeEventListener("intersectFound", resolveFound);
                self.removeEventListener("intersectNotFound", resolveNotFound);
                resolve(msg);
            }
            _this.once("intersectFound", resolveFound);
            _this.once("intersectNotFound", resolveNotFound);
            _this.mplexer.send(new messages_1.ChainSyncFindIntersect({ points: points }).toCbor().toBuffer(), {
                hasAgency: true,
                protocol: _this.mplexer.isN2N ?
                    MiniProtocol_1.MiniProtocol.ChainSync :
                    MiniProtocol_1.MiniProtocol.LocalChainSync
            });
        });
    };
    ChainSyncClient.prototype.done = function () {
        this.mplexer.send(new messages_1.ChainSyncMessageDone().toCbor().toBuffer(), {
            hasAgency: true,
            protocol: this.mplexer.isN2N ?
                MiniProtocol_1.MiniProtocol.ChainSync :
                MiniProtocol_1.MiniProtocol.LocalChainSync
        });
        this.clearListeners();
    };
    return ChainSyncClient;
}());
exports.ChainSyncClient = ChainSyncClient;
