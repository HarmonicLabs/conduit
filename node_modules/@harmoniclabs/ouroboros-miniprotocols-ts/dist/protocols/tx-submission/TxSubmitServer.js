"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxSubmitServer = void 0;
var TxSubmitMessage_1 = require("./TxSubmitMessage.js");
var TxSubmitReplyIds_1 = require("./messages/TxSubmitReplyIds.js");
var TxSubmitReplyTxs_1 = require("./messages/TxSubmitReplyTxs.js");
var TxSubmitDone_1 = require("./messages/TxSubmitDone.js");
var TxSubmitInit_1 = require("./messages/TxSubmitInit.js");
var cbor_1 = require("@harmoniclabs/cbor");
var MiniProtocol_1 = require("../../MiniProtocol/index.js");
var messages_1 = require("./messages/index.js");
function msgToName(msg) {
    if (msg instanceof TxSubmitInit_1.TxSubmitInit)
        return "init";
    if (msg instanceof TxSubmitReplyIds_1.TxSubmitReplyIds)
        return "replyIds";
    if (msg instanceof TxSubmitReplyTxs_1.TxSubmitReplyTxs)
        return "replyTxs";
    if (msg instanceof TxSubmitDone_1.TxSubmitDone)
        return "done";
    return undefined;
}
function isTxSubServerEvtName(stuff) {
    return (stuff === "done" ||
        stuff === "replyIds" ||
        stuff === "replyTxs" ||
        stuff === "done");
}
var TxSubmitServer = /** @class */ (function () {
    function TxSubmitServer(thisMultiplexer) {
        this._eventListeners = Object.freeze({
            init: [],
            replyIds: [],
            replyTxs: [],
            done: []
        });
        this._onceEventListeners = Object.freeze({
            init: [],
            replyIds: [],
            replyTxs: [],
            done: []
        });
        var self = this;
        this.mplexer = thisMultiplexer;
        var prevBytes = undefined;
        var queque = [];
        this.mplexer.on(MiniProtocol_1.MiniProtocol.TxSubmission, function (chunk) {
            if (!self.hasEventListeners())
                return;
            var offset = -1;
            var thing;
            var msg;
            if (prevBytes) {
                var tmp = new Uint8Array(prevBytes.length + chunk.length);
                tmp.set(prevBytes, 0);
                tmp.set(chunk, prevBytes.length);
                chunk = tmp;
                prevBytes = undefined;
            }
            while (true) {
                try {
                    thing = cbor_1.Cbor.parseWithOffset(chunk);
                }
                catch (_a) {
                    prevBytes = chunk.slice();
                    break;
                }
                offset = thing.offset;
                msg = (0, TxSubmitMessage_1.txSubmitMessageFromCborObj)(thing.parsed);
                queque.unshift(msg);
                if (offset < chunk.length) {
                    chunk = chunk.subarray(offset);
                    continue;
                }
                else {
                    prevBytes = undefined;
                    break;
                }
            }
            var msgStr;
            while (msg = queque.pop()) {
                msgStr = msgToName(msg);
                if (!msgStr)
                    continue;
                self.dispatchEvent(msgStr, msg);
            }
        });
    }
    TxSubmitServer.prototype.requestTxIds = function (requesting, acknowleged, blocking) {
        if (acknowleged === void 0) { acknowleged = 0; }
        if (blocking === void 0) { blocking = false; }
        // 4 bytes unsigned integers
        acknowleged = acknowleged >>> 0;
        requesting = requesting >>> 0;
        var self = this;
        return new Promise(function (resolve) {
            function handleReply(msg) {
                self.off("replyIds", handleReply);
                blocking && self.off("done", handleReply);
                resolve(msg);
            }
            self.on("replyIds", handleReply);
            blocking && self.on("done", handleReply);
            self.mplexer.send(new messages_1.TxSubmitRequestIds({
                blocking: blocking,
                knownTxCount: acknowleged,
                requestedTxCount: requesting
            }).toCbor().toBuffer(), {
                hasAgency: true,
                protocol: MiniProtocol_1.MiniProtocol.TxSubmission
            });
        });
    };
    TxSubmitServer.prototype.requestTxs = function (txHashes) {
        var self = this;
        return new Promise(function (resolve) {
            function handleReply(msg) {
                self.off("replyTxs", handleReply);
                resolve(msg);
            }
            self.on("replyTxs", handleReply);
            self.mplexer.send(new TxSubmitReplyTxs_1.TxSubmitReplyTxs({ txs: txHashes }).toCbor().toBuffer(), {
                hasAgency: true,
                protocol: MiniProtocol_1.MiniProtocol.TxSubmission
            });
        });
    };
    TxSubmitServer.prototype.hasEventListeners = function () {
        return _hasEventListeners(this._eventListeners) || _hasEventListeners(this._onceEventListeners);
    };
    TxSubmitServer.prototype.addEventListenerOnce = function (evt, listener) {
        var listeners = this._onceEventListeners[evt];
        if (!Array.isArray(listeners))
            return self;
        listeners.push(listener);
        return self;
    };
    TxSubmitServer.prototype.addEventListener = function (evt, listener, options) {
        if (options === null || options === void 0 ? void 0 : options.once)
            return this.addEventListenerOnce(evt, listener);
        var listeners = this._eventListeners[evt];
        if (!Array.isArray(listeners))
            return self;
        listeners.push(listener);
        return self;
    };
    TxSubmitServer.prototype.removeEventListener = function (evt, listener) {
        var listeners = this._eventListeners[evt];
        if (!Array.isArray(listeners))
            return self;
        this._eventListeners[evt] = listeners.filter(function (fn) { return fn !== listener; });
        this._onceEventListeners[evt] = this._onceEventListeners[evt].filter(function (fn) { return fn !== listener; });
        return self;
    };
    TxSubmitServer.prototype.dispatchEvent = function (evt, msg) {
        var e_1, _a;
        var listeners = this._eventListeners[evt];
        if (!listeners)
            return;
        try {
            for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
                var cb_1 = listeners_1_1.value;
                cb_1(msg);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        listeners = this._onceEventListeners[evt];
        var cb;
        while (cb = listeners.shift())
            cb(msg);
        return true;
    };
    TxSubmitServer.prototype.clearListeners = function (evt) {
        _clearListeners(this._eventListeners, evt);
        _clearListeners(this._onceEventListeners, evt);
    };
    return TxSubmitServer;
}());
exports.TxSubmitServer = TxSubmitServer;
function _hasEventListeners(listeners) {
    return (listeners.init.length > 0 ||
        listeners.replyIds.length > 0 ||
        listeners.replyTxs.length > 0 ||
        listeners.done.length > 0);
}
function _clearListeners(listeners, evt) {
    if (isTxSubServerEvtName(evt)) {
        listeners[evt] = [];
    }
    else {
        for (var key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                listeners[key] = [];
            }
        }
    }
}
