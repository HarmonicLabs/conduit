"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockFetchClient = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var MiniProtocol_1 = require("../../MiniProtocol/index.js");
var ChainPoint_1 = require("../types/ChainPoint.js");
var BlockFetchBatchDone_1 = require("./messages/BlockFetchBatchDone.js");
var BlockFetchClientDone_1 = require("./messages/BlockFetchClientDone.js");
var BlockFetchMessage_1 = require("./BlockFetchMessage.js");
var BlockFetchNoBlocks_1 = require("./messages/BlockFetchNoBlocks.js");
var BlockFetchRequestRange_1 = require("./messages/BlockFetchRequestRange.js");
var BlockFetchStartBatch_1 = require("./messages/BlockFetchStartBatch.js");
var BlockFetchBlock_1 = require("./messages/BlockFetchBlock.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var roDescr = {
    writable: false,
    enumerable: true,
    configurable: false
};
function isAnyBlockFetchClientEvtName(evt) {
    return typeof evt === "string" && (evt === "requestRange" ||
        evt === "noBlocks" ||
        evt === "startBatch" ||
        evt === "batchDone" ||
        evt === "clientDone" ||
        evt === "block" ||
        evt === "error");
}
function msgToName(msg) {
    if (msg instanceof BlockFetchRequestRange_1.BlockFetchRequestRange)
        return "requestRange";
    if (msg instanceof BlockFetchNoBlocks_1.BlockFetchNoBlocks)
        return "noBlocks";
    if (msg instanceof BlockFetchBlock_1.BlockFetchBlock)
        return "block";
    if (msg instanceof BlockFetchStartBatch_1.BlockFetchStartBatch)
        return "startBatch";
    if (msg instanceof BlockFetchBatchDone_1.BlockFetchBatchDone)
        return "batchDone";
    if (msg instanceof BlockFetchClientDone_1.BlockFetchClientDone)
        return "clientDone";
    if (msg instanceof Error)
        return "error";
    return undefined;
}
var BlockFetchClient = /** @class */ (function () {
    function BlockFetchClient(multiplexer) {
        var self = this;
        var eventListeners = {
            requestRange: [],
            noBlocks: [],
            startBatch: [],
            batchDone: [],
            clientDone: [],
            block: [],
            error: []
        };
        var onceEventListeners = {
            requestRange: [],
            noBlocks: [],
            startBatch: [],
            batchDone: [],
            clientDone: [],
            block: [],
            error: []
        };
        function clearListeners(evt) {
            if (isAnyBlockFetchClientEvtName(evt)) {
                eventListeners[evt].length = 0;
                onceEventListeners[evt].length = 0;
                return self;
            }
            eventListeners.requestRange.length = 0;
            eventListeners.noBlocks.length = 0;
            eventListeners.startBatch.length = 0;
            eventListeners.batchDone.length = 0;
            eventListeners.clientDone.length = 0;
            eventListeners.block.length = 0;
            eventListeners.error.length = 0;
            onceEventListeners.requestRange.length = 0;
            onceEventListeners.noBlocks.length = 0;
            onceEventListeners.startBatch.length = 0;
            onceEventListeners.batchDone.length = 0;
            onceEventListeners.clientDone.length = 0;
            onceEventListeners.block.length = 0;
            onceEventListeners.error.length = 0;
            return self;
        }
        function hasEventListeners(includeError) {
            if (includeError === void 0) { includeError = false; }
            return (includeError ? (eventListeners.error.length > 0 ||
                onceEventListeners.error.length > 0) : true) && (eventListeners.requestRange.length > 0 ||
                eventListeners.noBlocks.length > 0 ||
                eventListeners.startBatch.length > 0 ||
                eventListeners.batchDone.length > 0 ||
                eventListeners.clientDone.length > 0 ||
                eventListeners.block.length > 0 ||
                onceEventListeners.requestRange.length > 0 ||
                onceEventListeners.noBlocks.length > 0 ||
                onceEventListeners.startBatch.length > 0 ||
                onceEventListeners.batchDone.length > 0 ||
                onceEventListeners.clientDone.length > 0 ||
                onceEventListeners.block.length > 0);
        }
        /** @deprecated */
        function onRequestRange(cb) {
            eventListeners.requestRange.push(cb);
        }
        /** @deprecated */
        function onNoBlocks(cb) {
            eventListeners.noBlocks.push(cb);
        }
        /** @deprecated */
        function onBlock(cb) {
            eventListeners.block.push(cb);
        }
        /** @deprecated */
        function onStartBatch(cb) {
            eventListeners.startBatch.push(cb);
        }
        /** @deprecated */
        function onBatchDone(cb) {
            eventListeners.batchDone.push(cb);
        }
        /** @deprecated */
        function onClientDone(cb) {
            eventListeners.clientDone.push(cb);
        }
        function addEventListenerOnce(evt, listener) {
            if (!isAnyBlockFetchClientEvtName(evt))
                return self;
            onceEventListeners[evt].push(listener);
            return self;
        }
        function addEventListener(evt, listener, opts) {
            if ((opts === null || opts === void 0 ? void 0 : opts.once) === true)
                return addEventListenerOnce(evt, listener);
            if (!isAnyBlockFetchClientEvtName(evt))
                return self;
            eventListeners[evt].push(listener);
            return self;
        }
        function removeEventListener(evt, listener) {
            if (!isAnyBlockFetchClientEvtName(evt))
                return self;
            eventListeners[evt] = eventListeners[evt].filter(function (fn) { return fn !== listener; });
            onceEventListeners[evt] = onceEventListeners[evt].filter(function (fn) { return fn !== listener; });
            return self;
        }
        function dispatchEvent(evt, msg) {
            if (!isAnyBlockFetchClientEvtName(evt))
                return true;
            if (evt !== "error" && !(0, BlockFetchMessage_1.isBlockFetchMessage)(msg))
                return true;
            var listeners = eventListeners[evt];
            var nListeners = listeners.length;
            for (var i = 0; i < nListeners; i++) {
                listeners[i](msg);
            }
            var onceListeners = onceEventListeners[evt];
            if (evt === "error" && nListeners + onceListeners.length === 0) {
                throw msg instanceof Error ? msg : new Error("Unhandled error: " + msg);
            }
            var cb;
            while (cb = onceListeners.shift()) {
                cb(msg);
            }
            return true;
        }
        Object.defineProperties(this, {
            mplexer: __assign({ value: multiplexer }, roDescr),
            clearListeners: __assign({ value: clearListeners }, roDescr),
            removeAllListeners: __assign({ value: clearListeners }, roDescr),
            onRequestRange: __assign({ value: onRequestRange }, roDescr),
            onNoBlocks: __assign({ value: onNoBlocks }, roDescr),
            onBlock: __assign({ value: onBlock }, roDescr),
            onStartBatch: __assign({ value: onStartBatch }, roDescr),
            onBatchDone: __assign({ value: onBatchDone }, roDescr),
            onClientDone: __assign({ value: onClientDone }, roDescr),
            addEventListener: __assign({ value: addEventListener }, roDescr),
            addListener: __assign({ value: addEventListener }, roDescr),
            on: __assign({ value: addEventListener }, roDescr),
            once: __assign({ value: addEventListenerOnce }, roDescr),
            removeEventListener: __assign({ value: removeEventListener }, roDescr),
            removeListener: __assign({ value: removeEventListener }, roDescr),
            off: __assign({ value: removeEventListener }, roDescr),
            dispatchEvent: __assign({ value: dispatchEvent }, roDescr),
            emit: __assign({ value: dispatchEvent }, roDescr),
        });
        var prevBytes = undefined;
        var queque = [];
        multiplexer.on(MiniProtocol_1.MiniProtocol.BlockFetch, function (chunk) {
            if (!hasEventListeners())
                return;
            var offset = -1;
            var thing;
            var msg;
            // const dbg_chunk = Uint8Array.prototype.slice.call( chunk );
            // const dbg_prev = prevBytes ? Uint8Array.prototype.slice.call( prevBytes ) : prevBytes;
            if (prevBytes) {
                var tmp = new Uint8Array(prevBytes.length + chunk.length);
                tmp.set(prevBytes, 0);
                tmp.set(chunk, prevBytes.length);
                chunk = tmp;
                prevBytes = undefined;
            }
            while (offset < chunk.length) {
                var originalSTLimit = Error.stackTraceLimit;
                Error.stackTraceLimit = 0;
                try {
                    thing = cbor_1.Cbor.parseWithOffset(chunk);
                }
                catch (_a) {
                    Error.stackTraceLimit = originalSTLimit;
                    // assume the error is of "missing bytes";
                    prevBytes = Uint8Array.prototype.slice.call(chunk);
                    break;
                }
                // finally {
                //     Error.stackTraceLimit = originalSTLimit;
                // }
                offset = thing.offset;
                try {
                    msg = (0, BlockFetchMessage_1.blockFetchMessageFromCborObj)(thing.parsed);
                    // @ts-ignore Cannot assign to 'cborBytes' because it is a read-only property.ts(2540)
                    msg.cborBytes = Uint8Array.prototype.slice.call(chunk, 0, offset);
                    queque.unshift(msg);
                }
                catch (e) {
                    // before dispatch event
                    Error.stackTraceLimit = originalSTLimit;
                    // console.error("-------------------------------------------------------");
                    // console.error( "dbg_chunk", toHex( dbg_chunk ) );
                    // console.error( "dbg_prev", dbg_prev ? toHex( dbg_prev ) : dbg_prev );
                    // console.error("-------------------------------------------------------");
                    var err = new Error((typeof (e === null || e === void 0 ? void 0 : e.message) === "string" ? e.message : "") +
                        "\ndata: " + (0, uint8array_utils_1.toHex)(chunk) + "\n");
                    dispatchEvent("error", err);
                }
                finally {
                    Error.stackTraceLimit = originalSTLimit;
                }
                if (offset < chunk.length) {
                    // reference same memory (`subarray`)
                    // ignore the parsed bytes
                    chunk = chunk.subarray(offset);
                    offset = -1;
                }
            }
            var msgStr;
            while (msg = queque.pop()) {
                msgStr = msgToName(msg);
                if (!msgStr)
                    continue; // ingore messages not expected by the client
                dispatchEvent(msgStr, msg);
            }
        });
    }
    /** request a single block from peer */
    BlockFetchClient.prototype.request = function (point) {
        return this.requestRange(point, point)
            .then(function (result) { return Array.isArray(result) ? result[0] : result; });
    };
    BlockFetchClient.prototype.requestRange = function (from, to) {
        if ((0, ChainPoint_1.isOriginPoint)(from) || (0, ChainPoint_1.isOriginPoint)(to)) {
            this.dispatchEvent("error", new Error("trying to request origin point; " +
                "The Genesis Block exsists as a concept, but not really in a node database; " +
                "BlockFetchClient::requestRange will resolve with `BlockFetchNoBlocks`; " +
                "try with the first real block point"));
            return Promise.resolve(new BlockFetchNoBlocks_1.BlockFetchNoBlocks());
        }
        var self = this;
        var blocks = [];
        return new Promise(function (resolve) {
            function resolveBatch(_msg) {
                self.removeEventListener("noBlocks", resolveNoBlocks);
                self.removeEventListener("batchDone", resolveBatch);
                self.removeEventListener("block", handleBlock);
                if (blocks.length > 0)
                    resolve(blocks);
                else
                    resolve(new BlockFetchNoBlocks_1.BlockFetchNoBlocks());
                return;
            }
            function resolveNoBlocks(msg) {
                self.removeEventListener("noBlocks", resolveNoBlocks);
                self.removeEventListener("batchDone", resolveBatch);
                self.removeEventListener("block", handleBlock);
                resolve(msg);
                return;
            }
            // function handleStartBatch( msg: BlockFetchStartBatch ) {}
            function handleBlock(msg) {
                blocks.push(msg);
            }
            self.once("noBlocks", resolveNoBlocks);
            self.once("batchDone", resolveBatch);
            self.on("block", handleBlock);
            self.mplexer.send(new BlockFetchRequestRange_1.BlockFetchRequestRange({ from: from, to: to }).toCbor().toBuffer(), {
                hasAgency: true,
                protocol: MiniProtocol_1.MiniProtocol.BlockFetch
            });
        });
    };
    BlockFetchClient.prototype.done = function () {
        this.mplexer.send(new BlockFetchClientDone_1.BlockFetchClientDone().toCbor().toBuffer(), {
            hasAgency: true,
            protocol: MiniProtocol_1.MiniProtocol.BlockFetch
        });
        this.clearListeners();
    };
    return BlockFetchClient;
}());
exports.BlockFetchClient = BlockFetchClient;
