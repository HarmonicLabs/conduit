"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStateQueryClient = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var MiniProtocol_1 = require("../../MiniProtocol/index.js");
var QryAcquired_1 = require("./messages/QryAcquired.js");
var QryDone_1 = require("./messages/QryDone.js");
var QryFailure_1 = require("./messages/QryFailure.js");
var QryMessage_1 = require("./QryMessage.js");
var QryQuery_1 = require("./messages/QryQuery.js");
var QryRelease_1 = require("./messages/QryRelease.js");
var QryResult_1 = require("./messages/QryResult.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var messages_1 = require("./messages/index.js");
var roDescr = Object.freeze({
    writable: false,
    enumerable: true,
    configurable: false
});
function _clearListeners(listeners, evt) {
    if (isLocalStateQueryEvtName(evt)) {
        listeners[evt].length = 0;
        return;
    }
    listeners.acquire.length = 0;
    listeners.failure.length = 0;
    listeners.acquired.length = 0;
    listeners.reacquire.length = 0;
    listeners.query.length = 0;
    listeners.result.length = 0;
    listeners.release.length = 0;
    listeners.done.length = 0;
    listeners.error.length = 0;
    return;
}
function _hasEventListeners(listeners, includeError) {
    return (includeError ? listeners.error.length > 0 : true) && (listeners.acquire.length > 0 ||
        listeners.failure.length > 0 ||
        listeners.acquired.length > 0 ||
        listeners.reacquire.length > 0 ||
        listeners.query.length > 0 ||
        listeners.result.length > 0 ||
        listeners.release.length > 0 ||
        listeners.done.length > 0);
}
function isLocalStateQueryEvtName(str) {
    return (str === "acquire" ||
        str === "failure" ||
        str === "acquired" ||
        str === "reacquire" ||
        str === "query" ||
        str === "result" ||
        str === "release" ||
        str === "done" ||
        str === "error");
}
function msgToName(msg) {
    if (msg instanceof messages_1.QryAcquire)
        return "acquire";
    if (msg instanceof QryFailure_1.QryFailure)
        return "failure";
    if (msg instanceof QryAcquired_1.QryAcquired)
        return "acquired";
    if (msg instanceof messages_1.QryReAcquire)
        return "reacquire";
    if (msg instanceof QryQuery_1.QryQuery)
        return "query";
    if (msg instanceof QryResult_1.QryResult)
        return "result";
    if (msg instanceof QryRelease_1.QryRelease)
        return "release";
    if (msg instanceof QryDone_1.QryDone)
        return "done";
    return undefined;
}
var lsqClientHeader = Object.freeze({
    hasAgency: true,
    protocol: MiniProtocol_1.MiniProtocol.LocalStateQuery
});
var LocalStateQueryClient = /** @class */ (function () {
    function LocalStateQueryClient(multiplexer) {
        var self = this;
        var eventListeners = {
            acquire: [],
            failure: [],
            acquired: [],
            reacquire: [],
            query: [],
            result: [],
            release: [],
            done: [],
            error: []
        };
        var onceEventListeners = {
            acquire: [],
            failure: [],
            acquired: [],
            reacquire: [],
            query: [],
            result: [],
            release: [],
            done: [],
            error: []
        };
        function clearListeners(eventName) {
            if (isLocalStateQueryEvtName(eventName)) {
                eventListeners[eventName].length = 0;
                onceEventListeners[eventName].length = 0;
                return self;
            }
            _clearListeners(eventListeners);
            _clearListeners(onceEventListeners);
            return self;
        }
        function hasEventListeners(includeError) {
            if (includeError === void 0) { includeError = false; }
            return (_hasEventListeners(eventListeners, includeError) ||
                _hasEventListeners(onceEventListeners, includeError));
        }
        function addEventListenerOnce(eventName, listener) {
            if (!isLocalStateQueryEvtName(eventName))
                return self;
            onceEventListeners[eventName].push(listener);
            return self;
        }
        function addEventListener(eventName, listener, opts) {
            if ((opts === null || opts === void 0 ? void 0 : opts.once) === true)
                return addEventListenerOnce(eventName, listener);
            if (!isLocalStateQueryEvtName(eventName))
                return self;
            eventListeners[eventName].push(listener);
            return self;
        }
        function removeEventListener(eventName, listener) {
            if (!isLocalStateQueryEvtName(eventName))
                return self;
            eventListeners[eventName] = eventListeners[eventName].filter(function (fn) { return fn !== listener; });
            onceEventListeners[eventName] = onceEventListeners[eventName].filter(function (fn) { return fn !== listener; });
            return self;
        }
        function dispatchEvent(eventName, msg) {
            if (!isLocalStateQueryEvtName(eventName))
                return true;
            if (eventName !== "error" && !(0, QryMessage_1.isQryMessage)(msg))
                return true;
            var listeners = eventListeners[eventName];
            var nListeners = listeners.length;
            for (var i = 0; i < nListeners; i++) {
                listeners[i](msg);
            }
            var onceListeners = onceEventListeners[eventName];
            if (eventName === "error" && nListeners + onceListeners.length === 0) {
                throw msg instanceof Error ? msg : new Error("Unhandled error: " + msg);
            }
            var cb;
            while (cb = onceListeners.shift()) {
                cb(msg);
            }
            return true;
        }
        Object.defineProperties(this, {
            mplexer: __assign({ value: multiplexer }, roDescr),
            clearListeners: __assign({ value: clearListeners }, roDescr),
            removeAllListeners: __assign({ value: clearListeners }, roDescr),
            addEventListener: __assign({ value: addEventListener }, roDescr),
            addListener: __assign({ value: addEventListener }, roDescr),
            on: __assign({ value: addEventListener }, roDescr),
            once: __assign({ value: addEventListenerOnce }, roDescr),
            removeEventListener: __assign({ value: removeEventListener }, roDescr),
            removeListener: __assign({ value: removeEventListener }, roDescr),
            off: __assign({ value: removeEventListener }, roDescr),
            dispatchEvent: __assign({ value: dispatchEvent }, roDescr),
            emit: __assign({ value: dispatchEvent }, roDescr),
        });
        var prevBytes = undefined;
        var queque = [];
        multiplexer.on(MiniProtocol_1.MiniProtocol.LocalStateQuery, function (chunk) {
            if (!hasEventListeners())
                return;
            var offset = -1;
            var thing;
            var msg;
            if (prevBytes) {
                var tmp = new Uint8Array(prevBytes.length + chunk.length);
                tmp.set(prevBytes, 0);
                tmp.set(chunk, prevBytes.length);
                chunk = tmp;
                prevBytes = undefined;
            }
            while (offset < chunk.length) {
                var originalSTLimit = Error.stackTraceLimit;
                Error.stackTraceLimit = 0;
                try {
                    thing = cbor_1.Cbor.parseWithOffset(chunk);
                }
                catch (_a) {
                    Error.stackTraceLimit = originalSTLimit;
                    // assume the error is of "missing bytes";
                    prevBytes = Uint8Array.prototype.slice.call(chunk);
                    break;
                }
                offset = thing.offset;
                // Error.stackTraceLimit = originalSTLimit;
                try {
                    msg = (0, QryMessage_1.localStateQueryMessageFromCborObj)(thing.parsed);
                    // @ts-ignore Cannot assign to 'cborBytes' because it is a read-only property.ts(2540)
                    msg.cborBytes = Uint8Array.prototype.slice.call(chunk, 0, offset);
                    queque.unshift(msg);
                }
                catch (e) {
                    // before dispatch event
                    Error.stackTraceLimit = originalSTLimit;
                    var err = typeof (e === null || e === void 0 ? void 0 : e.message) === "string" ?
                        new Error(e.message +
                            "\ndata: " + (0, uint8array_utils_1.toHex)(chunk) + "\n") :
                        new Error("\ndata: " + (0, uint8array_utils_1.toHex)(chunk) + "\n");
                    dispatchEvent("error", err);
                }
                finally {
                    Error.stackTraceLimit = 0;
                }
                if (offset < chunk.length) {
                    // reference same memory (`subarray`)
                    // ignore the parsed bytes
                    chunk = chunk.subarray(offset);
                }
            }
            var msgStr;
            while (msg = queque.pop()) {
                msgStr = msgToName(msg);
                if (!msgStr)
                    continue; // ingore messages not expected by the client
                dispatchEvent(msgStr, msg);
            }
        });
    }
    LocalStateQueryClient.prototype.sendAcquire = function (point) {
        this.mplexer.send(new messages_1.QryAcquire({ point: point }).toCbor().toBuffer(), lsqClientHeader);
    };
    LocalStateQueryClient.prototype.acquire = function (point) {
        var lsqClient = this;
        // acquire tip local chain sync
        return new Promise(function (resolve, reject) {
            function handleFailure(msg) {
                lsqClient.removeEventListener("acquired", resolveAcquired);
                lsqClient.removeEventListener("failure", handleFailure);
                reject(msg);
            }
            function resolveAcquired() {
                lsqClient.removeEventListener("acquired", resolveAcquired);
                lsqClient.removeEventListener("failure", handleFailure);
                resolve();
            }
            lsqClient.on("failure", handleFailure);
            lsqClient.on("acquired", resolveAcquired);
            lsqClient.sendAcquire(point);
        });
    };
    LocalStateQueryClient.prototype.sendQuery = function (query) {
        this.mplexer.send(new QryQuery_1.QryQuery({ query: query }).toCbor().toBuffer(), lsqClientHeader);
    };
    LocalStateQueryClient.prototype.query = function (query, timeout) {
        var lsqClient = this;
        // acquire tip local chain sync
        return new Promise(function (resolve, reject) {
            var timeoutHandle = undefined;
            function removeTimeout() {
                if (typeof timeout !== "number")
                    return;
                clearTimeout(timeoutHandle);
            }
            function handleResult(msg) {
                lsqClient.removeEventListener("result", handleResult);
                removeTimeout();
                resolve(msg);
            }
            function handleTimeout() {
                lsqClient.removeEventListener("result", handleResult);
                removeTimeout();
                reject(new Error("timed-out"));
            }
            if (typeof timeout === "number") {
                timeoutHandle = setTimeout(handleTimeout, timeout);
            }
            lsqClient.on("result", handleResult);
            lsqClient.sendQuery(query);
        });
    };
    LocalStateQueryClient.prototype.sendRelease = function () {
        this.mplexer.send(new QryRelease_1.QryRelease().toCbor().toBuffer(), lsqClientHeader);
    };
    LocalStateQueryClient.prototype.release = function () {
        this.sendRelease();
    };
    LocalStateQueryClient.prototype.done = function () {
        this.mplexer.send(new QryDone_1.QryDone().toCbor().toBuffer(), lsqClientHeader);
        this.clearListeners();
    };
    LocalStateQueryClient.prototype.requestCurrentEra = function (timeout) {
        return __awaiter(this, void 0, void 0, function () {
            var qry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.query(new cbor_1.CborArray([
                            new cbor_1.CborUInt(0),
                            new cbor_1.CborArray([
                                new cbor_1.CborUInt(2),
                                new cbor_1.CborArray([
                                    new cbor_1.CborUInt(1)
                                ])
                            ])
                        ]), timeout)];
                    case 1:
                        qry = _a.sent();
                        if (!(qry.result instanceof cbor_1.CborUInt))
                            throw new Error("unexpected cbor result to query era; received: " +
                                qry.toCbor().toString());
                        return [2 /*return*/, qry.result.num];
                }
            });
        });
    };
    return LocalStateQueryClient;
}());
exports.LocalStateQueryClient = LocalStateQueryClient;
