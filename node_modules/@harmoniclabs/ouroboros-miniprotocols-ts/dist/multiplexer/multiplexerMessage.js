"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapMultiplexerMessage = wrapMultiplexerMessage;
exports.unwrapMultiplexerMessage = unwrapMultiplexerMessage;
exports.unwrapMultiplexerMessages = unwrapMultiplexerMessages;
function wrapMultiplexerMessage(payload, _a) {
    // Mini Protocol ID The unique ID of the mini protocol as in tables 2.2 and 2.3.
    var protocol = _a.protocol, hasAgency = _a.hasAgency;
    /**
     * - 4 bytes (32 bits) for transmission time (calculated only at the end)
     * - 1 bit for _mode_:
     *      - `0` if the sender has agency (initiates the mini protocol)
     *      - `1` otherwhise
     * - 15 bits for the mini protocol ID (see `MiniProtocol` enum above)
     * - 16 bits for the payload-length
     * - payload
    **/
    var buff = new ArrayBuffer(payload.length + 8);
    var result = new Uint8Array(buff);
    var view = new DataView(buff);
    view.setUint16(4, // byteOffset
    /**
     * - 1 bit for _mode_:
     *     - `0` if the sender has agency (initiates the mini protocol)
     *     - `1` otherwhise
     */
    (hasAgency ? 0 : 1 << 15) |
        // - 15 bits for the mini protocol ID (see `MiniProtocol` enum above)
        (protocol & 0xffff), false);
    view.setUint16(6, // byteOffset
    // - 16 bits for the payload-length
    payload.length & 0xffff, false);
    // - payload
    result.set(payload, 8);
    // - 4 bytes (32 bits) for transmission time (calculated only at the end)
    //
    // Transmission Time
    // The transmission time is a time stamp based
    // the **lower 32 bits** of the senderâ€™s **monotonic clock**
    // with a resolution of one microsecond.
    view.setInt32(0, Math.ceil(performance.timeOrigin * 1000 + performance.now() * 1000) & 0xffffffff, false);
    return result;
}
var agencyMask = 0x8000; // ( 1 << 15 )
var protoclMask = 0x7fff; // ~agencyMask & 0xffff;
/**
 * @deprecated use `unwrapMultiplexerMessages`
 */
function unwrapMultiplexerMessage(message) {
    var agencyAndProtocol = message[4] << 8 | message[5];
    var payloadLen = message[6] << 8 | message[7];
    return {
        header: {
            transmissionTime: (message[0] << 24) | (message[1] << 16) | (message[2] << 8) | message[3],
            hasAgency: (agencyAndProtocol & agencyMask) > 0,
            protocol: agencyAndProtocol & protoclMask,
            payloadLength: payloadLen
        },
        payload: message.slice(8, 8 + payloadLen)
    };
}
function unwrapMultiplexerMessages(message) {
    var messages = [];
    while (message.length >= 8) {
        var view = new DataView(message.buffer);
        // bitwise opeartor (or and shift) implicitly convert to signed int32
        // but these are 2 bytes long numbers, hence always positive
        var agencyAndProtocol = message[4] << 8 | message[5];
        var payloadLen = message[6] << 8 | message[7];
        messages.push({
            header: {
                transmissionTime: view.getUint32(0, false),
                hasAgency: (agencyAndProtocol & agencyMask) > 0,
                protocol: agencyAndProtocol & protoclMask,
                payloadLength: payloadLen
            },
            payload: Uint8Array.prototype.slice.call(message, 8, 8 + payloadLen)
        });
        message = Uint8Array.prototype.slice.call(message, 8 + payloadLen);
    }
    return messages;
}
