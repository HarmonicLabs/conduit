import { MiniProtocol, MiniProtocolNum, MiniProtocolStr } from "../MiniProtocol/index.js";
import { SocketLike, WrappedSocket } from "./SocketLike.js";
import { MultiplexerHeader, MultiplexerHeaderInfos } from "./multiplexerMessage.js";
import { DataListener, ErrorListener } from "../common/ErrorListener.js";
export type MultiplexerEvtListener = (payload: Uint8Array, header: MultiplexerHeader) => void;
type MultiplexerEvtListeners = {
    [MiniProtocol.BlockFetch]: MultiplexerEvtListener[];
    [MiniProtocol.ChainSync]: MultiplexerEvtListener[];
    [MiniProtocol.Handshake]: MultiplexerEvtListener[];
    [MiniProtocol.KeepAlive]: MultiplexerEvtListener[];
    [MiniProtocol.LocalChainSync]: MultiplexerEvtListener[];
    [MiniProtocol.LocalStateQuery]: MultiplexerEvtListener[];
    [MiniProtocol.LocalTxSubmission]: MultiplexerEvtListener[];
    [MiniProtocol.TxSubmission]: MultiplexerEvtListener[];
    [MiniProtocol.LocalTxMonitor]: MultiplexerEvtListener[];
    [MiniProtocol.PeerSharing]: MultiplexerEvtListener[];
    error: ((err: Error) => void)[];
    data: ((data: Uint8Array) => void)[];
    send: ((payload: Uint8Array, headerInfos: MultiplexerHeaderInfos) => void)[];
};
export type MultiplexerProtocolType = "node-to-node" | "node-to-client";
export interface MultiplexerConfig {
    protocolType: MultiplexerProtocolType;
    connect: () => SocketLike;
    initialListeners?: Partial<MultiplexerEvtListeners>;
    initialOnceListeners?: Partial<MultiplexerEvtListeners>;
}
export type MultiplexerCloseOptions = {
    /**
     * @default true
    **/
    closeSocket: boolean;
};
export type MplexerEvtName = "error" | "data" | "send" | MiniProtocol | MiniProtocolStr | MiniProtocolNum;
export declare function isMplexerEvtName(thing: any): thing is MplexerEvtName;
export type AnyMplexerListener = MultiplexerEvtListener | ErrorListener;
export type MplexerListenerOf<Evt extends MplexerEvtName> = Evt extends "error" ? ErrorListener : Evt extends "data" ? DataListener : Evt extends "send" ? DataListener : MultiplexerEvtListener;
export type ArgsOf<Evt extends MplexerEvtName> = Evt extends "error" ? [err: Error] : Evt extends "data" ? [data: Uint8Array] : Evt extends "send" ? [payload: Uint8Array, header: MultiplexerHeaderInfos] : [
    payload: Uint8Array,
    header: MultiplexerHeader
];
export declare class Multiplexer {
    readonly socket: WrappedSocket;
    readonly isN2N: boolean;
    readonly clearListeners: (protocol?: MiniProtocol) => void;
    addEventListener: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>, opts?: AddEventListenerOptions) => this;
    addListener: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>) => this;
    on: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>) => this;
    once: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>) => this;
    removeEventListener: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>) => this;
    removeListener: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>) => this;
    off: <Evt extends MplexerEvtName>(evt: Evt, listener: MplexerListenerOf<Evt>) => this;
    removeAllListeners: <Evt extends MplexerEvtName>(evt?: Evt) => this;
    emit: <Evt extends MplexerEvtName>(evt: Evt, ...args: ArgsOf<Evt>) => boolean;
    dispatchEvent: <Evt extends MplexerEvtName>(evt: Evt, ...args: ArgsOf<Evt>) => boolean;
    send: (payload: Uint8Array, header: MultiplexerHeaderInfos) => void;
    close: (options?: MultiplexerCloseOptions) => void;
    isClosed: () => boolean;
    constructor(cfg: MultiplexerConfig);
}
export {};
