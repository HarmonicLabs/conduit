"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNodeSocketLike = isNodeSocketLike;
exports.isWebSocketLike = isWebSocketLike;
exports.isNode2NodeSocket = isNode2NodeSocket;
exports.wrapSocket = wrapSocket;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
function isNodeSocketLike(s) {
    return (0, obj_utils_1.isObject)(s) && (typeof s.end === "function" &&
        typeof s.write === "function" &&
        typeof s.on === "function" &&
        typeof s.removeListener === "function");
}
function isWebSocketLike(s) {
    return (0, obj_utils_1.isObject)(s) && (typeof s.send === "function" &&
        typeof s.close === "function" &&
        typeof s.addEventListener === "function" &&
        typeof s.removeEventListener === "function");
}
function isNode2NodeSocket(socketLike) {
    var _a;
    // WebSockets only n2n
    if (isWebSocketLike(socketLike))
        return true;
    return isNodeSocketLike(socketLike) &&
        // UNIX socket address (node-to-client) is `{}` 
        Object.keys((_a = socketLike.address()) !== null && _a !== void 0 ? _a : {}).length > 0;
}
function webSocketLikeIsClosed() {
    return this.readyState >= 2;
}
function webSocketLikeIsReady() {
    return this.readyState === 1;
}
function nodeSocketLikeIsClosed() {
    return this.destroyed;
}
function nodeSocketLikeIsReady() {
    return !this.connecting && !this.pending && !this.destroyed;
}
function wrapSocket(socketLike, reconnect) {
    var _evts = {};
    function reconnectSocket() {
        var socket = reconnect.call(socketLike);
    }
    if (isWebSocketLike(socketLike)) {
        var socket = {
            unwrap: function () { return socketLike; },
            reconnect: reconnect.bind(socketLike),
            isClosed: webSocketLikeIsClosed.bind(socketLike),
            isReady: webSocketLikeIsReady.bind(socketLike),
            send: socketLike.send.bind(socketLike),
            close: socketLike.close.bind(socketLike),
            on: function (evt, listener) {
                if (evt === "close") {
                    socketLike.addEventListener("close", listener);
                }
                else if (evt === "error") {
                    socketLike.addEventListener("error", listener);
                }
                else if (evt === "connect") {
                    socketLike.addEventListener("open", listener);
                }
                else if (evt === "data") {
                    socketLike.addEventListener("message", function (evt) { return listener(new Uint8Array(evt.data)); });
                }
                else {
                    // unknown event type; ignore
                }
            },
            off: function (evt, listener) {
                if (evt === "close") {
                    socketLike.removeEventListener("close", listener);
                }
                else if (evt === "error") {
                    socketLike.removeEventListener("error", listener);
                }
                else if (evt === "connect") {
                    socketLike.removeEventListener("open", listener);
                }
                else if (evt === "data") {
                    socketLike.removeEventListener("message", function (evt) { return listener(new Uint8Array(evt.data)); });
                }
                else {
                    // unknown event type; ignore
                }
            }
        };
        return Object.freeze(socket);
    }
    else if (isNodeSocketLike(socketLike)) {
        var socket = {
            unwrap: function () { return socketLike; },
            reconnect: reconnect.bind(socketLike),
            isClosed: nodeSocketLikeIsClosed.bind(socketLike),
            isReady: nodeSocketLikeIsReady.bind(socketLike),
            send: socketLike.write.bind(socketLike),
            close: socketLike.end.bind(socketLike),
            on: socketLike.on.bind(socketLike),
            off: socketLike.removeListener.bind(socketLike),
        };
        return Object.freeze(socket);
    }
    throw new Error("cannot wrap " + socketLike + " as a socket because it doesn't meet the 'SocketLike' interface");
}
