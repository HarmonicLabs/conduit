"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Multiplexer = void 0;
exports.isMplexerEvtName = isMplexerEvtName;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var MiniProtocol_1 = require("../MiniProtocol/index.js");
var SocketLike_1 = require("./SocketLike.js");
var multiplexerMessage_1 = require("./multiplexerMessage.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var MAX_RECONNECT_ATTEPMTS = 3;
var roDescr = {
    writable: false,
    enumerable: true,
    configurable: false
};
function isMplexerEvtName(thing) {
    return (thing === "error" ||
        thing === "data" ||
        thing === "send" ||
        (0, MiniProtocol_1.isMiniProtocolStr)(thing) ||
        (0, MiniProtocol_1.isMiniProtocolNum)(thing));
}
var Multiplexer = /** @class */ (function () {
    function Multiplexer(cfg) {
        var self = this;
        var reconnect = cfg.connect;
        var socketLike = reconnect();
        var socket = (0, SocketLike_1.wrapSocket)(socketLike, reconnect);
        var isN2N = cfg.protocolType !== "node-to-client";
        var _wasClosed = false;
        var reconnectAttepmts = 0;
        function reconnectSocket() {
            if (socket.isClosed())
                return;
            socket.on("connect", function () { return reconnectAttepmts = 0; });
            socket.on("close", reconnectSocket);
            socket.on("error", handleSocketError);
            socket.on("data", forwardMessage);
        }
        function normalizeEventName(evt) {
            if (!isMplexerEvtName(evt)) {
                dispatchEvent("error", new Error("unknown multiplexer event: " + evt));
                return "error";
            }
            if (evt === "error" ||
                evt === "data" ||
                evt === "send")
                return evt;
            evt = (0, MiniProtocol_1.miniProtocolToNumber)(evt);
            if (evt === MiniProtocol_1.MiniProtocol.Handshake ||
                evt === MiniProtocol_1.MiniProtocol.BlockFetch ||
                evt === MiniProtocol_1.MiniProtocol.LocalStateQuery ||
                evt === MiniProtocol_1.MiniProtocol.KeepAlive)
                return evt;
            if (isN2N) {
                if (evt === MiniProtocol_1.MiniProtocol.LocalChainSync)
                    evt = MiniProtocol_1.MiniProtocol.ChainSync;
                if (evt === MiniProtocol_1.MiniProtocol.LocalTxSubmission)
                    evt = MiniProtocol_1.MiniProtocol.TxSubmission;
            }
            else // node-to-client
             {
                if (evt === MiniProtocol_1.MiniProtocol.ChainSync)
                    evt = MiniProtocol_1.MiniProtocol.LocalChainSync;
                if (evt === MiniProtocol_1.MiniProtocol.TxSubmission)
                    evt = MiniProtocol_1.MiniProtocol.LocalTxSubmission;
            }
            return evt;
        }
        var eventListeners = getInitialListeners(cfg.initialListeners);
        var onceEventListeners = getInitialListeners(cfg.initialOnceListeners);
        function handleSocketError(thing) {
            _wasClosed = true;
            var err = new Error("socket error");
            err.data = thing;
            dispatchEvent("error", err);
            return;
        }
        var prevBytes = undefined;
        var prevHeader = undefined;
        function forwardMessage(chunk) {
            var e_1, _a;
            self.dispatchEvent("data", chunk);
            if (prevBytes) {
                var tmp = new Uint8Array(prevBytes.length + chunk.length);
                tmp.set(prevBytes, 0);
                tmp.set(chunk, prevBytes.length);
                chunk = tmp;
                prevBytes = undefined;
            }
            var messages;
            if (prevHeader) {
                if (chunk.length < prevHeader.payloadLength) {
                    // not enough bytes to cover message
                    // remember for later
                    prevBytes = chunk;
                    // exit `forwardMessage` without sending any event.
                    return;
                }
                messages = [
                    {
                        header: prevHeader,
                        payload: Uint8Array.prototype.slice.call(chunk, 0, prevHeader.payloadLength)
                    }
                ];
                chunk = Uint8Array.prototype.subarray.call(chunk, prevHeader.payloadLength, chunk.length);
                prevHeader = undefined;
            }
            else
                messages = [];
            // finally add any other message if present
            messages = messages.concat((0, multiplexerMessage_1.unwrapMultiplexerMessages)(chunk));
            try {
                for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
                    var _b = messages_1_1.value, header = _b.header, payload = _b.payload;
                    if (header.payloadLength > payload.length) {
                        prevBytes = payload;
                        prevHeader = header;
                        break;
                    }
                    if (!(0, MiniProtocol_1.isMiniProtocol)(header.protocol)) {
                        var err = new Error("unwrapped Multiplexer header was not a mini protocol;\nmultiplexer chunk received: " +
                            (0, uint8array_utils_1.toHex)(Uint8Array.prototype.slice.call(chunk)));
                        dispatchEvent("error", err);
                        return;
                    }
                    dispatchEvent(header.protocol, payload, header);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) _a.call(messages_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        function clearListeners(protocol) {
            if (protocol !== undefined) {
                protocol = protocol === "error" || protocol === "data" || protocol === "send" ? protocol :
                    (0, MiniProtocol_1.miniProtocolToNumber)(protocol);
                eventListeners[protocol].length = 0;
                onceEventListeners[protocol].length = 0;
                return;
            }
            // else (protocol === undefined)
            eventListeners[MiniProtocol_1.MiniProtocol.Handshake].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.ChainSync].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.LocalChainSync].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.BlockFetch].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.TxSubmission].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.LocalTxSubmission].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.LocalStateQuery].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.KeepAlive].length = 0;
            eventListeners[MiniProtocol_1.MiniProtocol.PeerSharing].length = 0;
            eventListeners.error.length = 0;
            eventListeners.data.length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.Handshake].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.ChainSync].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.LocalChainSync].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.BlockFetch].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.TxSubmission].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.LocalTxSubmission].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.LocalStateQuery].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.KeepAlive].length = 0;
            onceEventListeners[MiniProtocol_1.MiniProtocol.PeerSharing].length = 0;
            onceEventListeners.error.length = 0;
            onceEventListeners.data.length = 0;
        }
        socket.on("close", reconnectSocket);
        socket.on("error", handleSocketError);
        socket.on("data", forwardMessage);
        function close(options) {
            socket.off("close", reconnectSocket);
            socket.off("error", handleSocketError);
            socket.off("data", forwardMessage);
            var closeSocket = options ?
                (options.closeSocket === false ? false : true) :
                true;
            if (closeSocket && !socket.isClosed())
                socket.close();
            _wasClosed = true;
        }
        function isClosed() { return _wasClosed; }
        function send(payload, header, attempt) {
            if (attempt === void 0) { attempt = 0; }
            if (isClosed())
                return;
            self.dispatchEvent("send", payload, header);
            try {
                void socket.send((0, multiplexerMessage_1.wrapMultiplexerMessage)(payload, header));
            }
            catch (e) {
                attempt = Math.max(0, Number(attempt));
                // Math.max( 0, NaN ) -> NaN
                if (!Number.isSafeInteger(attempt))
                    attempt = 0;
                if (attempt >= MAX_RECONNECT_ATTEPMTS)
                    throw e;
                reconnectSocket();
                void send(payload, header, attempt + 1);
            }
        }
        function addEventListenerOnce(evt, listener) {
            if (!isMplexerEvtName(evt))
                return self;
            evt = normalizeEventName(evt);
            if (evt === "error") {
                onceEventListeners.error.push(listener);
                return self;
            }
            else if (evt === "data") {
                onceEventListeners.data.push(listener);
                return self;
            }
            else if (evt === "send") {
                onceEventListeners.send.push(listener);
                return self;
            }
            evt = (0, MiniProtocol_1.miniProtocolToNumber)(evt);
            onceEventListeners[evt].push(listener);
            return self;
        }
        function addEventListener(evt, listener, opts) {
            if (opts === null || opts === void 0 ? void 0 : opts.once)
                return addEventListenerOnce(evt, listener);
            if (!isMplexerEvtName(evt))
                return self;
            evt = normalizeEventName(evt);
            if (evt === "error") {
                eventListeners.error.push(listener);
                return self;
            }
            else if (evt === "data") {
                eventListeners.data.push(listener);
                return self;
            }
            else if (evt === "send") {
                eventListeners.send.push(listener);
                return self;
            }
            evt = (0, MiniProtocol_1.miniProtocolToNumber)(evt);
            eventListeners[evt].push(listener);
            return self;
        }
        function removeEventListener(evt, listener) {
            if (!isMplexerEvtName(evt))
                return self;
            evt = normalizeEventName(evt);
            if (evt === "error") {
                eventListeners.error = eventListeners.error.filter(function (fn) { return fn !== listener; });
                onceEventListeners.error = eventListeners.error.filter(function (fn) { return fn !== listener; });
                return self;
            }
            else if (evt === "data") {
                eventListeners.data = eventListeners.data.filter(function (fn) { return fn !== listener; });
                onceEventListeners.data = eventListeners.data.filter(function (fn) { return fn !== listener; });
                return self;
            }
            else if (evt === "send") {
                eventListeners.send = eventListeners.send.filter(function (fn) { return fn !== listener; });
                onceEventListeners.send = eventListeners.send.filter(function (fn) { return fn !== listener; });
                return self;
            }
            evt = (0, MiniProtocol_1.miniProtocolToNumber)(evt);
            eventListeners[evt] = eventListeners[evt].filter(function (fn) { return fn !== listener; });
            onceEventListeners[evt] = eventListeners[evt].filter(function (fn) { return fn !== listener; });
            return self;
        }
        function dispatchEvent(evt) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            // console.log( eventName, msg );
            if (!isMplexerEvtName(evt))
                return true;
            evt = normalizeEventName(evt);
            var listeners = eventListeners[evt];
            var onceListeners = onceEventListeners[evt];
            var nListeners = listeners.length;
            var totListeners = nListeners + onceListeners.length;
            if (totListeners <= 0) {
                if (evt === "error")
                    throw (_a = args[0]) !== null && _a !== void 0 ? _a : new Error("unhandled error");
                else
                    return true;
            }
            for (var i = 0; i < nListeners; i++) {
                // @ts-ignore
                listeners[i].apply(listeners, __spreadArray([], __read(args), false));
            }
            var cb;
            while (cb = onceListeners.shift()) {
                cb.apply(void 0, __spreadArray([], __read(args), false));
            }
            return true;
        }
        Object.defineProperties(this, {
            socket: {
                // if reconnect is called it might change (expecially with websockets)
                get: function () { return socket; },
                set: function () { },
                enumerable: true,
                configurable: false
            },
            isN2N: __assign({ value: isN2N }, roDescr),
            send: __assign({ value: send }, roDescr),
            close: __assign({ value: close }, roDescr),
            isClosed: __assign({ value: isClosed }, roDescr),
            clearListeners: __assign({ value: clearListeners }, roDescr),
            addEventListener: __assign({ value: addEventListener }, roDescr),
            addListener: __assign({ value: addEventListener }, roDescr),
            on: __assign({ value: addEventListener }, roDescr),
            once: __assign({ value: addEventListenerOnce }, roDescr),
            removeEventListener: __assign({ value: removeEventListener }, roDescr),
            removeListener: __assign({ value: removeEventListener }, roDescr),
            off: __assign({ value: removeEventListener }, roDescr),
            removeAllListeners: __assign({ value: clearListeners }, roDescr),
            emit: __assign({ value: dispatchEvent }, roDescr),
            dispatchEvent: __assign({ value: dispatchEvent }, roDescr),
        });
    }
    return Multiplexer;
}());
exports.Multiplexer = Multiplexer;
function getInitialListeners(cfgListeneres) {
    var _a, e_2, _b;
    var listeners = (_a = {},
        _a[MiniProtocol_1.MiniProtocol.Handshake] = [],
        _a[MiniProtocol_1.MiniProtocol.ChainSync] = [],
        _a[MiniProtocol_1.MiniProtocol.LocalChainSync] = [],
        _a[MiniProtocol_1.MiniProtocol.BlockFetch] = [],
        _a[MiniProtocol_1.MiniProtocol.TxSubmission] = [],
        _a[MiniProtocol_1.MiniProtocol.LocalTxSubmission] = [],
        _a[MiniProtocol_1.MiniProtocol.LocalStateQuery] = [],
        _a[MiniProtocol_1.MiniProtocol.KeepAlive] = [],
        _a[MiniProtocol_1.MiniProtocol.LocalTxMonitor] = [],
        _a[MiniProtocol_1.MiniProtocol.PeerSharing] = [],
        _a.error = [],
        _a.data = [],
        _a.send = [],
        _a);
    if (cfgListeneres === undefined ||
        !(0, obj_utils_1.isObject)(cfgListeneres))
        return listeners;
    var keys = [
        MiniProtocol_1.MiniProtocol.Handshake,
        MiniProtocol_1.MiniProtocol.ChainSync,
        MiniProtocol_1.MiniProtocol.LocalChainSync,
        MiniProtocol_1.MiniProtocol.BlockFetch,
        MiniProtocol_1.MiniProtocol.TxSubmission,
        MiniProtocol_1.MiniProtocol.LocalTxSubmission,
        MiniProtocol_1.MiniProtocol.LocalStateQuery,
        MiniProtocol_1.MiniProtocol.KeepAlive,
        MiniProtocol_1.MiniProtocol.LocalTxMonitor,
        MiniProtocol_1.MiniProtocol.PeerSharing,
        "error",
        "data",
        "send"
    ];
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            if (!Array.isArray(cfgListeneres[key]))
                continue;
            /// @ts-ignore
            listeners[key] = cfgListeneres[key].filter(function (thing) { return typeof thing === "function"; });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_b = keys_1.return)) _b.call(keys_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return listeners;
}
