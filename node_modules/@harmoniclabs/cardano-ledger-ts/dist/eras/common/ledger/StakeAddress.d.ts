import { byte } from "@harmoniclabs/crypto";
import { CanBeCborString, CborObj, SubCborRef } from "@harmoniclabs/cbor";
import { NetworkT } from "./Network.js";
import { StakeCredentials, StakeValidatorHash } from "../../../credentials/StakeCredentials.js";
import { StakeKeyHash } from "../../../credentials/StakeKeyHash.js";
import { CredentialType } from "../../../credentials/index.js";
import { Credential } from "../../../credentials/index.js";
export type StakeAddressBech32 = `stake1${string}` | `stake_test1${string}`;
export type StakeAddressType = "stakeKey" | "script";
export type StakeAddressCredentials<T extends StakeAddressType> = T extends "stakeKey" ? StakeKeyHash : StakeValidatorHash;
export interface IStakeAddress<T extends StakeAddressType = StakeAddressType> {
    network: NetworkT;
    credentials: StakeAddressCredentials<T>;
    type: StakeAddressType;
}
export declare class StakeAddress<T extends StakeAddressType = StakeAddressType> {
    readonly cborRef: SubCborRef | undefined;
    readonly network: NetworkT;
    readonly credentials: StakeAddressCredentials<T>;
    readonly type: T;
    constructor(stakeAddress: IStakeAddress<T>, cborRef?: SubCborRef | undefined);
    clone(): StakeAddress<T>;
    toString(): StakeAddressBech32;
    static fromString(str: string): StakeAddress;
    static fromString<T extends StakeAddressType = StakeAddressType>(str: string, type: T): StakeAddress<T>;
    toBuffer(): Uint8Array;
    toBytes(): byte[];
    static fromBytes(bs: byte[] | string | Uint8Array, netwok?: NetworkT, type?: StakeAddressType): StakeAddress;
    toCborObj(): CborObj;
    static fromCbor(cStr: CanBeCborString): StakeAddress;
    static fromCborObj(cObj: CborObj): StakeAddress;
    toCredential(): Credential<CredentialType>;
    toStakeCredentials(): StakeCredentials;
}
