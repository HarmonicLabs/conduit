"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaryBlock = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var InvalidCborFormatError_1 = require("../../../utils/InvalidCborFormatError.js");
var MaryHeader_1 = require("../header/MaryHeader.js");
var MaryTxBody_1 = require("../tx/MaryTxBody.js");
var MaryTxWitnessSet_1 = require("../tx/MaryTxWitnessSet.js");
var MaryAuxiliaryData_1 = require("../tx/MaryAuxiliaryData.js");
var getSubCborRef_1 = require("../../../utils/getSubCborRef.js");
var MaryBlock = /** @class */ (function () {
    function MaryBlock(block, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        this.cborRef = cborRef;
        // make transactionBodies and transactionWitnessSets have same length
        if (block.transactionBodies.length !== block.transactionWitnessSets.length) {
            throw new Error("Transaction bodies and witness sets must have the same length");
        }
        this.header = new MaryHeader_1.MaryHeader(block.header);
        this.transactionBodies = block.transactionBodies.map(function (tb) { return new MaryTxBody_1.MaryTxBody(tb); });
        this.transactionWitnessSets = block.transactionWitnessSets.map(function (tws) { return new MaryTxWitnessSet_1.MaryTxWitnessSet(tws); });
        this.auxiliaryDataSet = Object.fromEntries(Object.entries(block.auxiliaryDataSet).map(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            return [key, new MaryAuxiliaryData_1.MaryAuxiliaryData(value)];
        }));
    }
    MaryBlock.prototype.toCborBytes = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return this.cborRef.toBuffer();
        return this.toCbor().toBuffer();
    };
    MaryBlock.prototype.toCbor = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return new cbor_1.CborString(this.cborRef.toBuffer());
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    MaryBlock.prototype.toCborObj = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef) {
            return cbor_1.Cbor.parse(this.cborRef.toBuffer());
        }
        return new cbor_1.CborArray([
            this.header.toCborObj(),
            new cbor_1.CborArray(this.transactionBodies.map(function (tb) { return tb.toCborObj(); })),
            new cbor_1.CborArray(this.transactionWitnessSets.map(function (tws) { return tws.toCborObj(); })),
            new cbor_1.CborMap(Object.entries(this.auxiliaryDataSet).map(function (_a) {
                var _b = __read(_a, 2), k = _b[0], v = _b[1];
                return ({
                    k: new cbor_1.CborUInt(BigInt(k)),
                    v: v.toCborObj()
                });
            })),
        ]);
    };
    ;
    MaryBlock.fromCbor = function (cbor) {
        // console.log("MaryBlock.fromCbor", cbor);
        var bytes = cbor instanceof Uint8Array ? cbor : (0, cbor_1.forceCborString)(cbor).toBuffer();
        return MaryBlock.fromCborObj(cbor_1.Cbor.parse(bytes, { keepRef: true }), bytes);
    };
    ;
    MaryBlock.fromCborObj = function (cObj, _originalBytes) {
        var e_1, _a;
        // console.log("MaryBlock.fromCborObj", cObj);
        if (!(cObj instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Mary Block must be a CBOR array with at least 5 elements");
        // console.log("cObj Mary: ", cObj);
        var _header = cObj.array[0];
        var _txBodies = cObj.array[1];
        var _txWitnessSets = cObj.array[2];
        var _auxDataSet = cObj.array[3];
        // console.log("_txWitnessSets Mary: ", _txWitnessSets);
        // Process header
        if (!(_header instanceof cbor_1.CborArray
            && _header.array.length >= 2))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Header must be a CBOR array with at least 2 elements");
        var header = MaryHeader_1.MaryHeader.fromCborObj(_header); // Assuming MaryHeader expects [header_body, body_signature]
        // Process transaction bodies
        if (!(_txBodies instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Transaction bodies must be a CBOR array");
        var transactionBodies = _txBodies.array.map(function (tb, index) {
            if (!(0, cbor_1.isCborObj)(tb))
                throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid CBOR object at transaction_bodies[".concat(index, "]"));
            return MaryTxBody_1.MaryTxBody.fromCborObj(tb);
        });
        // Process transaction witness sets
        if (!(_txWitnessSets instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Transaction witness sets must be a CBOR array");
        var transactionWitnessSets = _txWitnessSets.array.map(function (tws, index) {
            if (!(0, cbor_1.isCborObj)(tws)) {
                throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid CBOR object at transaction_witness_sets[".concat(index, "]"));
            }
            // console.log("tws", tws);
            return MaryTxWitnessSet_1.MaryTxWitnessSet.fromCborObj(tws);
        });
        // Process auxiliary data set
        if (!(_auxDataSet instanceof cbor_1.CborMap))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Auxiliary data set must be a CBOR map");
        var auxiliaryDataSet = {};
        try {
            for (var _b = __values(_auxDataSet.map), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                var k = entry.k, v = entry.v;
                if (!(k instanceof cbor_1.CborUInt))
                    throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid key in auxiliary_data_set");
                var txIndex = Number(k.num);
                if (!(Number.isSafeInteger(txIndex)))
                    throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid transaction index: ".concat(k.num));
                if (!((0, cbor_1.isCborObj)(v)))
                    throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid AUX data CBOR object at index ".concat(txIndex));
                auxiliaryDataSet[txIndex] = MaryAuxiliaryData_1.MaryAuxiliaryData.fromCborObj(v);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var conwayBlock = new MaryBlock({
            header: header,
            transactionBodies: transactionBodies,
            transactionWitnessSets: transactionWitnessSets,
            auxiliaryDataSet: auxiliaryDataSet
        }, (0, getSubCborRef_1.getSubCborRef)(cObj));
        return conwayBlock;
    };
    MaryBlock.prototype.toJSON = function () {
        return this.toJson();
    };
    ;
    MaryBlock.prototype.toJson = function () {
        return {
            header: this.header,
            transactionBodies: this.transactionBodies.map(function (txBody) { return txBody.toJson(); }),
            transactionWitnessSets: this.transactionWitnessSets.map(function (txWitSet) { return txWitSet.toJson(); }),
            auxiliaryDataSet: Object.entries(this.auxiliaryDataSet).reduce(function (acc, _a) {
                var _b;
                var _c = __read(_a, 2), k = _c[0], v = _c[1];
                return (__assign(__assign({}, acc), (_b = {}, _b[k] = v.toJson(), _b)));
            })
        };
    };
    ;
    return MaryBlock;
}());
exports.MaryBlock = MaryBlock;
