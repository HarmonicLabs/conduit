"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BabbageBlock = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var InvalidCborFormatError_1 = require("../../../utils/InvalidCborFormatError.js");
var BabbageHeader_1 = require("../header/BabbageHeader.js");
var BabbageTxBody_1 = require("../tx/BabbageTxBody.js");
var BabbageTxWitnessSet_1 = require("../tx/BabbageTxWitnessSet.js");
var BabbageAuxiliaryData_1 = require("../tx/BabbageAuxiliaryData.js");
var getSubCborRef_1 = require("../../../utils/getSubCborRef.js");
var BabbageBlock = /** @class */ (function () {
    function BabbageBlock(block, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        this.cborRef = cborRef;
        // make transactionBodies and transactionWitnessSets have same length
        if (block.transactionBodies.length !== block.transactionWitnessSets.length) {
            throw new Error("Transaction bodies and witness sets must have the same length");
        }
        this.header = new BabbageHeader_1.BabbageHeader(block.header);
        this.transactionBodies = block.transactionBodies.map(function (tb) { return new BabbageTxBody_1.BabbageTxBody(tb); });
        this.transactionWitnessSets = block.transactionWitnessSets.map(function (tws) { return new BabbageTxWitnessSet_1.BabbageTxWitnessSet(tws); });
        this.auxiliaryDataSet = Object.fromEntries(Object.entries(block.auxiliaryDataSet).map(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            return [key, new BabbageAuxiliaryData_1.BabbageAuxiliaryData(value)];
        }));
        this.invalidTransactions = block.invalidTransactions;
    }
    BabbageBlock.prototype.toCborBytes = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return this.cborRef.toBuffer();
        return this.toCbor().toBuffer();
    };
    BabbageBlock.prototype.toCbor = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return new cbor_1.CborString(this.cborRef.toBuffer());
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    BabbageBlock.prototype.toCborObj = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef) {
            return cbor_1.Cbor.parse(this.cborRef.toBuffer());
        }
        return new cbor_1.CborArray([
            this.header.toCborObj(),
            new cbor_1.CborArray(this.transactionBodies.map(function (tb) { return tb.toCborObj(); })),
            new cbor_1.CborArray(this.transactionWitnessSets.map(function (tws) { return tws.toCborObj(); })),
            new cbor_1.CborMap(Object.entries(this.auxiliaryDataSet).map(function (_a) {
                var _b = __read(_a, 2), k = _b[0], v = _b[1];
                return ({
                    k: new cbor_1.CborUInt(BigInt(k)),
                    v: v.toCborObj()
                });
            })),
            new cbor_1.CborArray((this.invalidTransactions || []).map(function (it) { return new cbor_1.CborUInt(BigInt(it)); }))
        ]);
    };
    ;
    BabbageBlock.fromCbor = function (cbor) {
        // console.log("BabbageBlock.fromCbor", cbor);
        var bytes = cbor instanceof Uint8Array ? cbor : (0, cbor_1.forceCborString)(cbor).toBuffer();
        return BabbageBlock.fromCborObj(cbor_1.Cbor.parse(bytes, { keepRef: true }), bytes);
    };
    ;
    BabbageBlock.fromCborObj = function (cObj, _originalBytes) {
        var e_1, _a;
        // console.log("BabbageBlock.fromCborObj", cObj);
        if (!(cObj instanceof cbor_1.CborArray && cObj.array.length >= 5)) {
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Babbage Block must be a CBOR array with at least 5 elements");
        }
        var _header = cObj.array[0];
        var _txBodies = cObj.array[1];
        var _txWitnessSets = cObj.array[2];
        var _auxDataSet = cObj.array[3];
        var _invalidTxs = cObj.array[4];
        // Process header
        if (!(_header instanceof cbor_1.CborArray
            && _header.array.length >= 2))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Header must be a CBOR array with at least 2 elements");
        var header = BabbageHeader_1.BabbageHeader.fromCborObj(_header); // Assuming BabbageHeader expects [header_body, body_signature]
        // Process transaction bodies
        if (!(_txBodies instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Transaction bodies must be a CBOR array");
        var transactionBodies = _txBodies.array.map(function (tb, index) {
            if (!(0, cbor_1.isCborObj)(tb))
                throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid CBOR object at transaction_bodies[".concat(index, "]"));
            return BabbageTxBody_1.BabbageTxBody.fromCborObj(tb);
        });
        // Process transaction witness sets
        if (!(_txWitnessSets instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Transaction witness sets must be a CBOR array");
        var transactionWitnessSets = _txWitnessSets.array.map(function (tws, index) {
            if (!(0, cbor_1.isCborObj)(tws)) {
                throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid CBOR object at transaction_witness_sets[".concat(index, "]"));
            }
            return BabbageTxWitnessSet_1.BabbageTxWitnessSet.fromCborObj(tws);
        });
        // Process auxiliary data set
        if (!(_auxDataSet instanceof cbor_1.CborMap))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Auxiliary data set must be a CBOR map");
        var auxiliaryDataSet = {};
        try {
            for (var _b = __values(_auxDataSet.map), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                var k = entry.k, v = entry.v;
                if (!(k instanceof cbor_1.CborUInt))
                    throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid key in auxiliary_data_set");
                var txIndex = Number(k.num);
                if (!(Number.isSafeInteger(txIndex)))
                    throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid transaction index: ".concat(k.num));
                if (!((0, cbor_1.isCborObj)(v)))
                    throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid AUX data CBOR object at index ".concat(txIndex));
                auxiliaryDataSet[txIndex] = BabbageAuxiliaryData_1.BabbageAuxiliaryData.fromCborObj(v);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Process invalid transactions
        if (!(_invalidTxs instanceof cbor_1.CborArray)) {
            throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid transactions must be a CBOR array");
        }
        var invalidTransactions = _invalidTxs.array.map(function (it, index) {
            if (!(it instanceof cbor_1.CborUInt))
                throw new InvalidCborFormatError_1.InvalidCborFormatError("Invalid type for transaction_index at invalid_transactions[".concat(index, "]"));
            return it.num;
        });
        var babbageBlock = new BabbageBlock({
            header: header,
            transactionBodies: transactionBodies,
            transactionWitnessSets: transactionWitnessSets,
            auxiliaryDataSet: auxiliaryDataSet,
            invalidTransactions: invalidTransactions
        }, (0, getSubCborRef_1.getSubCborRef)(cObj));
        return babbageBlock;
    };
    BabbageBlock.prototype.toJSON = function () {
        return this.toJson();
    };
    ;
    BabbageBlock.prototype.toJson = function () {
        return {
            header: this.header,
            transactionBodies: this.transactionBodies.map(function (txBody) { return txBody.toJson(); }),
            transactionWitnessSets: this.transactionWitnessSets.map(function (txWitSet) { return txWitSet.toJson(); }),
            auxiliaryDataSet: Object.entries(this.auxiliaryDataSet).reduce(function (acc, _a) {
                var _b;
                var _c = __read(_a, 2), k = _c[0], v = _c[1];
                return (__assign(__assign({}, acc), (_b = {}, _b[k] = v.toJson(), _b)));
            }, {}),
            invalidTransactions: this.invalidTransactions
        };
    };
    ;
    return BabbageBlock;
}());
exports.BabbageBlock = BabbageBlock;
