"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BabbageHeaderBody = exports.isIBabbageHeaderBody = void 0;
var ints_1 = require("@harmoniclabs/cbor/dist/utils/ints");
var cbor_1 = require("@harmoniclabs/cbor");
var crypto_1 = require("@harmoniclabs/crypto");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var hashes_1 = require("../../../hashes/index.js");
var Vrf_1 = require("../../common/Vrf.js");
var protocolVersion_1 = require("../protocol/protocolVersion.js");
var PoolOperationalCert_1 = require("../../common/certs/PoolOperationalCert.js");
var ints_2 = require("../../../utils/ints.js");
var getSubCborRef_1 = require("../../../utils/getSubCborRef.js");
var InvalidCborFormatError_1 = require("../../../utils/InvalidCborFormatError.js");
function isIBabbageHeaderBody(thing) {
    return (0, obj_utils_1.isObject)(thing) && (thing instanceof BabbageHeaderBody // already validated at construction, shortcut
        || ((0, ints_1.canBeUInteger)(thing.blockNumber)
            && (0, ints_1.canBeUInteger)(thing.slot)
            && (thing.prevHash === undefined || (0, hashes_1.canBeHash32)(thing.prevHash))
            && (0, hashes_1.canBeHash32)(thing.issuerPubKey)
            && (0, hashes_1.canBeHash32)(thing.vrfPubKey)
            && (0, Vrf_1.isIVrfCert)(thing.vrfResult)
            && (0, ints_1.canBeUInteger)(thing.blockBodySize)
            && (0, hashes_1.canBeHash32)(thing.blockBodyHash)
            && (0, PoolOperationalCert_1.isIPoolOperationalCert)(thing.opCert)
            && (0, protocolVersion_1.isIProtocolVersion)(thing.protocolVersion)));
}
exports.isIBabbageHeaderBody = isIBabbageHeaderBody;
var BabbageHeaderBody = /** @class */ (function () {
    function BabbageHeaderBody(hdrBody, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        this.cborRef = cborRef;
        if (!isIBabbageHeaderBody(hdrBody))
            throw new Error("Invalid BabbageHeaderBody");
        this.blockNumber = (0, ints_2.forceBigUInt)(hdrBody.blockNumber);
        this.slot = (0, ints_2.forceBigUInt)(hdrBody.slot);
        this.prevHash = typeof hdrBody.prevHash !== "undefined" ? (0, hashes_1.hash32bytes)(hdrBody.prevHash) : undefined;
        this.issuerPubKey = (0, hashes_1.hash32bytes)(hdrBody.issuerPubKey);
        this.vrfPubKey = (0, hashes_1.hash32bytes)(hdrBody.vrfPubKey);
        this.vrfResult = new Vrf_1.VrfCert(hdrBody.vrfResult);
        this.blockBodySize = (0, ints_2.u32)(hdrBody.blockBodySize);
        this.blockBodyHash = (0, hashes_1.hash32bytes)(hdrBody.blockBodyHash);
        this.opCert = new PoolOperationalCert_1.PoolOperationalCert(hdrBody.opCert);
        this.protocolVersion = new protocolVersion_1.ProtocolVersion(hdrBody.protocolVersion);
    }
    // just keep the leaderVrfOutput and nonceVrfOutput ones
    BabbageHeaderBody.prototype.leaderVrfOutput = function () {
        return (0, crypto_1.sha2_256_sync)(this.vrfResult.proofHash);
    };
    BabbageHeaderBody.prototype.clone = function () {
        var _a, _b;
        return new BabbageHeaderBody({
            blockNumber: this.blockNumber,
            slot: this.slot,
            prevHash: (_a = this.prevHash) === null || _a === void 0 ? void 0 : _a.slice(),
            issuerPubKey: this.issuerPubKey.slice(),
            vrfPubKey: this.vrfPubKey.slice(),
            vrfResult: this.vrfResult.clone(),
            blockBodySize: this.blockBodySize,
            blockBodyHash: this.blockBodyHash.slice(),
            opCert: this.opCert.clone(),
            protocolVersion: this.protocolVersion.clone()
        }, (_b = this.cborRef) === null || _b === void 0 ? void 0 : _b.clone());
    };
    BabbageHeaderBody.prototype.toCborBytes = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return this.cborRef.toBuffer();
        return this.toCbor().toBuffer();
    };
    BabbageHeaderBody.prototype.toCbor = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return new cbor_1.CborString(this.cborRef.toBuffer());
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    BabbageHeaderBody.prototype.toCborObj = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return cbor_1.Cbor.parse(this.cborRef.toBuffer());
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.blockNumber),
            new cbor_1.CborUInt(this.slot),
            this.prevHash ? new cbor_1.CborBytes(this.prevHash) : new cbor_1.CborSimple(null),
            new cbor_1.CborBytes(this.issuerPubKey),
            new cbor_1.CborBytes(this.vrfPubKey),
            this.vrfResult.toCborObj(),
            new cbor_1.CborUInt(this.blockBodySize),
            new cbor_1.CborBytes(this.blockBodyHash),
            this.opCert.toCborObj(),
            this.protocolVersion.toCborObj()
        ]);
    };
    /*
    CDDL:
        header_body = [block_number : uint
              , slot : uint
              , prev_hash : $hash32 / nil
              , issuer_vkey : $vkey
              , vrf_vkey : $vrf_vkey
              , vrf_result : $vrf_cert
              , block_body_size : uint
              , block_body_hash : $hash32
              , operational_cert
              , protocol_version]
    */
    BabbageHeaderBody.fromCbor = function (cbor) {
        var bytes = cbor instanceof Uint8Array ? cbor : (0, cbor_1.forceCborString)(cbor).toBuffer();
        return BabbageHeaderBody.fromCborObj(cbor_1.Cbor.parse(bytes, { keepRef: true }), bytes);
    };
    BabbageHeaderBody.fromCborObj = function (cHdrBody, _originalBytes) {
        // console.log("cHdrBody Babbage", cHdrBody);
        if (!(cHdrBody instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("BabbageHeaderBody");
        // console.log("cobj:", cHdrBody);
        var _a = __read(cHdrBody instanceof cbor_1.CborArray && cHdrBody.array.length === 10
            ? cHdrBody.array
            : cHdrBody instanceof cbor_1.CborArray && cHdrBody.array[0] instanceof cbor_1.CborArray
                ? cHdrBody.array[0].array
                : (function () { throw new InvalidCborFormatError_1.InvalidCborFormatError("BabbageHeaderBody"); })(), 10), _cBlockNo = _a[0], // block_number
        _cSlotNo = _a[1], // slot
        _cPrevHash = _a[2], // prev_hash
        _cIssuerVkey = _a[3], // issuer_vkey
        _cVrfVkey = _a[4], // vrf_vkey
        _cVrfCert = _a[5], // vrf_result
        _cBlockBodySize = _a[6], // block_body_size
        _cBlockBodyHash = _a[7], // block_body_hash
        _cOpCert = _a[8], // operational_cert
        _cProtVer = _a[9] // protocol_version
        ;
        if (!(_cBlockNo instanceof cbor_1.CborUInt &&
            _cSlotNo instanceof cbor_1.CborUInt &&
            (_cPrevHash instanceof cbor_1.CborBytes || _cPrevHash === undefined) && // Allow nil per CDDL
            _cIssuerVkey instanceof cbor_1.CborBytes &&
            _cVrfVkey instanceof cbor_1.CborBytes &&
            _cBlockBodySize instanceof cbor_1.CborUInt &&
            _cBlockBodyHash instanceof cbor_1.CborBytes)) {
            throw new Error("invalid cbor for BabbageHeaderBody");
        }
        var babbageHeaderBody = new BabbageHeaderBody({
            blockNumber: Number(_cBlockNo.num),
            slot: _cSlotNo.num,
            prevHash: _cPrevHash === null || _cPrevHash === void 0 ? void 0 : _cPrevHash.bytes,
            issuerPubKey: _cIssuerVkey.bytes,
            vrfPubKey: _cVrfVkey.bytes,
            vrfResult: Vrf_1.VrfCert.fromCborObj(_cVrfCert),
            blockBodySize: _cBlockBodySize.num,
            blockBodyHash: _cBlockBodyHash.bytes,
            opCert: PoolOperationalCert_1.PoolOperationalCert.fromCborObj(_cOpCert),
            protocolVersion: protocolVersion_1.ProtocolVersion.fromCborObj(_cProtVer)
        }, (0, getSubCborRef_1.getSubCborRef)(cHdrBody, _originalBytes));
        return babbageHeaderBody;
    };
    return BabbageHeaderBody;
}());
exports.BabbageHeaderBody = BabbageHeaderBody;
