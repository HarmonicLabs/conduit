"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakeAddress = void 0;
var StakeCredentials_1 = require("../credentials/StakeCredentials.js");
var StakeKeyHash_1 = require("../credentials/StakeKeyHash.js");
var Hash28_1 = require("../hashes/Hash28/Hash28.js");
var credentials_1 = require("../credentials/index.js");
var crypto_1 = require("@harmoniclabs/crypto");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var credentials_2 = require("../credentials/index.js");
var cbor_1 = require("@harmoniclabs/cbor");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
var StakeAddress = /** @class */ (function () {
    function StakeAddress(stakeAddress, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        this.cborRef = cborRef;
        var network = stakeAddress.network, credentials = stakeAddress.credentials, type = stakeAddress.type;
        var t = this.type === undefined ? (credentials instanceof StakeCredentials_1.StakeValidatorHash ? "script" : "stakeKey") : this.type;
        if (!(t === "script" ||
            t === "stakeKey"))
            throw new Error("invalid address type");
        this.type = type;
        if (!(network === "mainnet" ||
            network === "testnet"))
            throw new Error("invalid network");
        this.network = network;
        if (!(credentials instanceof Hash28_1.Hash28 &&
            ((t === "stakeKey" && !(credentials instanceof StakeCredentials_1.StakeValidatorHash)) ||
                (t === "script" && !(credentials instanceof StakeKeyHash_1.StakeKeyHash)))))
            throw new Error("invalid stake credentials");
        this.credentials = t === "stakeKey" ? new StakeKeyHash_1.StakeKeyHash(credentials) : new StakeCredentials_1.StakeValidatorHash(credentials);
        this.cborRef = cborRef !== null && cborRef !== void 0 ? cborRef : (0, getSubCborRef_1.subCborRefOrUndef)(stakeAddress);
    }
    StakeAddress.prototype.clone = function () {
        return new StakeAddress({
            network: this.network,
            credentials: this.credentials,
            type: this.type
        });
    };
    StakeAddress.prototype.toString = function () {
        return (0, crypto_1.encodeBech32)(this.network === "mainnet" ? "stake" : "stake_test", this.toBytes());
    };
    StakeAddress.fromString = function (str, type) {
        if (type === void 0) { type = "stakeKey"; }
        var _a = __read((0, crypto_1.decodeBech32)(str), 2), hrp = _a[0], creds = _a[1];
        if (hrp !== "stake" && hrp !== "stake_test")
            throw new Error("invalid stake address string");
        return StakeAddress.fromBytes(creds, hrp === "stake" ? "mainnet" : "testnet", type);
    };
    StakeAddress.prototype.toBuffer = function () {
        return new Uint8Array(this.toBytes());
    };
    StakeAddress.prototype.toBytes = function () {
        return [
            // header byte
            // second nubble = network
            ((this.network === "mainnet" ? 1 : 0) |
                // first nibble infos
                (this.type === "script" ? 240 : 224)),
        ].concat(Array.from(this.credentials.toBuffer()));
    };
    StakeAddress.fromBytes = function (bs, netwok, type) {
        if (netwok === void 0) { netwok = "mainnet"; }
        if (type === void 0) { type = "stakeKey"; }
        bs = Uint8Array.from(typeof bs === "string" ? (0, uint8array_utils_1.fromHex)(bs) : bs);
        if (bs.length === 29) {
            var header = bs[0];
            bs = bs.slice(1);
            type = Boolean(header & 16) ? "script" : "stakeKey";
            netwok = Boolean(header & 15) ? "mainnet" : "testnet";
        }
        return new StakeAddress({
            network: netwok,
            credentials: bs.length === 28 ? new Hash28_1.Hash28(bs) : new credentials_1.PublicKey(bs).hash,
            type: type
        });
    };
    StakeAddress.prototype.toCborObj = function () {
        return new cbor_1.CborBytes(this.toBuffer());
    };
    StakeAddress.fromCbor = function (cStr) {
        return StakeAddress.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr)));
    };
    StakeAddress.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR format for \"Hash\"");
        return StakeAddress.fromBytes(cObj.bytes);
    };
    StakeAddress.prototype.toCredential = function () {
        return new credentials_2.Credential({
            type: this.type === "script" ? credentials_1.CredentialType.Script : credentials_1.CredentialType.KeyHash,
            hash: new Hash28_1.Hash28(this.credentials)
        });
    };
    StakeAddress.prototype.toStakeCredentials = function () {
        return new StakeCredentials_1.StakeCredentials({
            type: this.type === "script" ? StakeCredentials_1.StakeCredentialsType.Script : StakeCredentials_1.StakeCredentialsType.KeyHash,
            hash: new Hash28_1.Hash28(this.credentials)
        });
    };
    return StakeAddress;
}());
exports.StakeAddress = StakeAddress;
