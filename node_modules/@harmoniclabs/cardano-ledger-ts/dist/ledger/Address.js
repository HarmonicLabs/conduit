"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = exports.isAddressStr = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var crypto_1 = require("@harmoniclabs/crypto");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var credentials_1 = require("../credentials/index.js");
var hashes_1 = require("../hashes/index.js");
var ints_1 = require("../utils/ints.js");
var maybeData_1 = require("../utils/maybeData.js");
var UPLCFlatUtils_1 = __importDefault(require("../utils/UPLCFlatUtils/index.js"));
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var bip32_ed25519_1 = require("@harmoniclabs/bip32_ed25519");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
function isAddressStr(stuff) {
    if (typeof stuff !== "string")
        return false;
    try {
        Address.fromString(stuff);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isAddressStr = isAddressStr;
/**
 * shelley specification in cardano-ledger; page 113
 */
var Address = /** @class */ (function () {
    function Address(address, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        this.cborRef = cborRef;
        var network = address.network, paymentCreds = address.paymentCreds, stakeCreds = address.stakeCreds, type = address.type;
        type = type === undefined ?
            (stakeCreds === undefined ? "enterprise" : "base")
            : type;
        if (!(type === "base" ||
            type === "enterprise" ||
            type === "bootstrap" ||
            type === "pointer"))
            throw new Error("invalid address type");
        this.type = type;
        if (!(network === "mainnet" ||
            network === "testnet"))
            throw new Error("invalid network");
        this.network = network;
        if (!(paymentCreds instanceof credentials_1.Credential))
            throw new Error("invalid payment credentials");
        this.paymentCreds = paymentCreds.clone();
        if (!(stakeCreds === undefined || stakeCreds instanceof credentials_1.StakeCredentials))
            throw new Error("invalid stake credentials");
        this.stakeCreds = stakeCreds === null || stakeCreds === void 0 ? void 0 : stakeCreds.clone();
    }
    Address.mainnet = function (paymentCreds, stakeCreds, type) {
        return new Address({
            network: "mainnet",
            paymentCreds: paymentCreds,
            stakeCreds: stakeCreds,
            type: type
        });
    };
    Address.testnet = function (paymentCreds, stakeCreds, type) {
        return new Address({
            network: "testnet",
            paymentCreds: paymentCreds,
            stakeCreds: stakeCreds,
            type: type
        });
    };
    Address.prototype.clone = function () {
        return new Address({
            network: this.network,
            paymentCreds: this.paymentCreds,
            stakeCreds: this.stakeCreds,
            type: this.type
        });
    };
    Object.defineProperty(Address, "fake", {
        get: function () {
            return new Address({
                network: "mainnet",
                paymentCreds: credentials_1.Credential.fake
            });
        },
        enumerable: false,
        configurable: true
    });
    Address.prototype.toData = function (version) {
        return new plutus_data_1.DataConstr(0, // export has only 1 constructor,
        [
            this.paymentCreds.toData(version),
            this.stakeCreds === undefined ?
                (0, maybeData_1.nothingData)() :
                (0, maybeData_1.justData)(this.stakeCreds.toData(version))
        ]);
    };
    Address.fromData = function (data, network) {
        if (network === void 0) { network = "mainnet"; }
        if (!(data instanceof plutus_data_1.DataConstr))
            throw new Error("invalid data for address");
        var _a = __read(data.fields, 2), creds = _a[0], maybeStakeCreds = _a[1];
        if (!(maybeStakeCreds instanceof plutus_data_1.DataConstr))
            throw new Error("invalid data for address");
        return new Address({
            network: network,
            paymentCreds: credentials_1.Credential.fromData(creds),
            stakeCreds: maybeStakeCreds.constr >= 1 ? undefined : // nothing
                credentials_1.StakeCredentials.fromData(maybeStakeCreds.fields[0])
        });
    };
    Address.prototype.toBytes = function () {
        var _a, _b, _c;
        return [(
            // header byte
            // second nubble = network
            (this.network === "mainnet" ? 1 : 0) |
                // first nibble infos  
                (this.type === "base" ? 0 :
                    this.type === "pointer" ? 64 :
                        this.type === "enterprise" ? 96 :
                            8 // bootstrap
                ) |
                (((_a = this.stakeCreds) === null || _a === void 0 ? void 0 : _a.type) === "script" ? 32 : 0) |
                (this.paymentCreds.type === credentials_1.CredentialType.Script ? 16 : 0))]
            .concat(Array.from(this.paymentCreds.hash.toBuffer()))
            .concat(this.stakeCreds === (void 0) ? [] : // add nothing
            Array.isArray(this.stakeCreds.hash) ? // pointer 
                this.stakeCreds.hash
                    .reduce(function (acc, n) {
                    return acc.concat(Array.from(UPLCFlatUtils_1.default.encodeBigIntAsVariableLengthBitStream((0, ints_1.forceBigUInt)(n)).toBuffer().buffer));
                }, []) :
                // hash (script or key)
                Array.from((_c = (_b = this.stakeCreds) === null || _b === void 0 ? void 0 : _b.hash.toBuffer()) !== null && _c !== void 0 ? _c : []));
    };
    Address.fromBytes = function (bs, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        bs = Array.from(typeof bs === "string" ? (0, uint8array_utils_1.fromHex)(bs) : bs);
        var _a = __read(bs), header = _a[0], payload = _a.slice(1);
        var addrType = (header & 240) >> 4;
        var network = ((header & 15)) === 1 ? "mainnet" : "testnet";
        var type = addrType <= 3 ? "base" :
            addrType <= 5 ? "pointer" :
                addrType <= 7 ? "enterprise" :
                    addrType === 8 ? "bootstrap" :
                        // addrType === 0b1110 || addrType === 0b1111 ? "stake" :
                        "unknown";
        var payment;
        var stake;
        var paymentType = (addrType & 1) === 1 ? credentials_1.CredentialType.Script : credentials_1.CredentialType.KeyHash;
        var stakeType = (addrType & 2) === 1 ? credentials_1.StakeCredentialsType.Script : credentials_1.StakeCredentialsType.KeyHash;
        switch (type) {
            case "base":
                if (payload.length !== (28 * 2))
                    throw new Error("address' header specifies a base adress but the payload is incorrect");
                payment = payload.slice(0, 28),
                    stake = payload.slice(28);
                break;
            case "bootstrap":
            case "enterprise":
            case "pointer":
                if (payload.length < 28) {
                    console.error((0, uint8array_utils_1.toHex)(new Uint8Array(payload)));
                    throw new Error("address' payload is incorrect; payload.length: " + payload.length.toString());
                }
                payment = payload.slice(0, 28),
                    stake = []; // ignore pointer; might change in future version
                break;
            default:
                throw new Error("unknown addres type; can't extract payload");
        }
        if (payment.length !== 28) {
            throw new Error("missing payment credentials");
        }
        return new Address({
            network: network,
            paymentCreds: new credentials_1.Credential({
                type: paymentType,
                hash: new hashes_1.Hash28(new Uint8Array(payment))
            }),
            stakeCreds: stake.length === 28 ?
                new credentials_1.StakeCredentials({
                    type: stakeType,
                    hash: new hashes_1.Hash28(new Uint8Array(stake))
                }) :
                undefined,
            type: type,
        }, cborRef);
    };
    ;
    Address.prototype.toBuffer = function () {
        return new Uint8Array(this.toBytes());
    };
    Address.fromBuffer = function (buff, cborRef) {
        if (cborRef === void 0) { cborRef = undefined; }
        return Address.fromBytes(typeof buff === "string" ?
            buff :
            Array.from(buff), cborRef);
    };
    /**
     * gets the standard address for single address wallets
     *
     * payment key at path "m/1852'/1815'/0'/0/0"
     * stake key at path   "m/1852'/1815'/0'/2/0"
    */
    Address.fromXPrv = function (xprv, network, AccountIndex, AddressIndex) {
        if (network === void 0) { network = "mainnet"; }
        if (AccountIndex === void 0) { AccountIndex = 0; }
        if (AddressIndex === void 0) { AddressIndex = 0; }
        var account = xprv
            .derive((0, bip32_ed25519_1.harden)(1852))
            .derive((0, bip32_ed25519_1.harden)(1815))
            .derive((0, bip32_ed25519_1.harden)(AccountIndex));
        var prv = account.derive(0).derive(AddressIndex);
        var pub = new credentials_1.PublicKey(prv.public().toPubKeyBytes());
        var pkh = pub.hash;
        var stake_prv = account.derive(2).derive(AddressIndex);
        var stake_pub = new credentials_1.PublicKey(stake_prv.public().toPubKeyBytes());
        var stake_pkh = stake_pub.hash;
        return new Address({
            network: network,
            paymentCreds: credentials_1.Credential.keyHash(pkh),
            stakeCreds: credentials_1.StakeCredentials.keyHash(stake_pkh),
        });
    };
    /**
     * generates an `XPrv` from entropy and calls `Addres.fromXPrv`
     *
     * gets the standard address for single address wallets
     *
     * payment key at path "m/1852'/1815'/0'/0/0"
     * stake key at path   "m/1852'/1815'/0'/2/0"
    */
    Address.fromEntropy = function (entropy, network, AccountIndex, AddressIndex) {
        if (network === void 0) { network = "mainnet"; }
        if (AccountIndex === void 0) { AccountIndex = 0; }
        if (AddressIndex === void 0) { AddressIndex = 0; }
        console.error("Address.fromEntropy Index", AccountIndex, AddressIndex);
        return Address.fromXPrv(bip32_ed25519_1.XPrv.fromEntropy(entropy), network, AccountIndex, AddressIndex);
    };
    Address.prototype.toCborObj = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.cborRef.toBuffer());
        }
        return new cbor_1.CborBytes(this.toBuffer());
    };
    Address.fromCborObj = function (buff) {
        if (!(buff instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR format for \"Address\"");
        return Address.fromBuffer(buff.bytes, (0, getSubCborRef_1.getSubCborRef)(buff));
    };
    Address.prototype.toCborBytes = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef)
            return this.cborRef.toBuffer();
        return this.toCbor().toBuffer();
    };
    Address.prototype.toCbor = function () {
        if (this.cborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.cborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    Address.fromCbor = function (cbor) {
        return Address.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cbor)));
    };
    Address.prototype.toString = function () {
        return (0, crypto_1.encodeBech32)(this.network === "mainnet" ? "addr" : "addr_test", this.toBytes());
    };
    Address.fromBech32 = function (addr) {
        return Address.fromString(addr);
    };
    Address.fromString = function (addr) {
        var _a = __read((0, crypto_1.decodeBech32)(addr), 2), hrp = _a[0], bytes = _a[1];
        var hrpNetwork;
        switch (hrp) {
            case "addr_test":
                hrpNetwork = "testnet";
                break;
            case "addr":
                hrpNetwork = "mainnet";
                break;
            default:
                throw new Error("string passed is not a Cardano address");
        }
        var _addr = Address.fromBytes(bytes);
        if (hrpNetwork !== _addr.network)
            throw new Error("ill formed address; human readable part netwok missmatches header byte network");
        return _addr;
    };
    Address.prototype.toJSON = function () { return this.toJson(); };
    Address.prototype.toJson = function () {
        return this.toString();
    };
    return Address;
}());
exports.Address = Address;
