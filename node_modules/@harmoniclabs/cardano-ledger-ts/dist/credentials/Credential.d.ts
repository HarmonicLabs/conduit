import { ToCbor, CborString, CborObj, CanBeCborString, SubCborRef } from "@harmoniclabs/cbor";
import { Cloneable } from "@harmoniclabs/cbor/dist/utils/Cloneable";
import { ToData, Data, DataConstr } from "@harmoniclabs/plutus-data";
import { CanBeHash28, Hash28 } from "../hashes/Hash28/Hash28.js";
import { PubKeyHash } from "./PubKeyHash.js";
export declare class ValidatorHash extends Hash28 {
}
export declare enum CredentialType {
    KeyHash = 0,
    Script = 1
}
export interface ICredential<T extends CredentialType = CredentialType> {
    type: T;
    hash: CanBeHash28;
}
export declare class Credential<T extends CredentialType = CredentialType> implements ToCbor, ToData, Cloneable<Credential<T>> {
    readonly cborRef: SubCborRef | undefined;
    readonly type: T;
    readonly hash: T extends CredentialType.KeyHash ? PubKeyHash : ValidatorHash;
    constructor(credential: ICredential<T>, cborRef?: SubCborRef | undefined);
    clone(): Credential<T>;
    static get fake(): Credential<CredentialType.KeyHash>;
    toData(_v?: any): DataConstr;
    static fromData(data: Data): Credential;
    /** @deprecated use `keyHash` instead */
    static pubKey(hash: Uint8Array | Hash28 | string): Credential<CredentialType.KeyHash>;
    static keyHash(hash: Uint8Array | Hash28 | string): Credential<CredentialType.KeyHash>;
    static script(hash: Uint8Array | Hash28 | string): Credential<CredentialType.Script>;
    toCborBytes(): Uint8Array;
    toCbor(): CborString;
    toCborObj(): CborObj;
    static fromCbor(cStr: CanBeCborString): Credential;
    static fromCborObj(cObj: CborObj): Credential;
    toJSON(): {
        credentialType: string;
        hash: string;
    };
    toJson(): {
        credentialType: string;
        hash: string;
    };
}
